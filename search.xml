<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[文件上传]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[文件上传前端页面必要条件 需要有一个form表单 form表单需要设置以下几个属性： action: 提交数据的目的地 method: 设置post enctype: 设置成multipart/form-data form里需要至少有一个file域： &lt;input type=”file” name=”xxx” /&gt; 后端技术所谓文件上传其实就是用流的方式，将文件从客户的电脑上通过网页中的表单， 以二进制流的方式，流到服务器的过程。 文件下载就是反过来， 将文件从服务器上通过二进制流的方式流到客户电脑上。 Servlet3.0上传方式Servlet3.0上传的核心： 一个注解、一个接口注解： @MultipartConfig： 开启Servlet文件上传功能 接口： javax.servlet.http.Part： 封装了上传的文件相关的所有信息 具体操作步骤 新建处理文件上传的Servlet，然后重写doPost方法 给Servlet添加@MultipartConfig注解，开启文件上传功能 Part part = request.getPart(“input type=’type’ name的值”); part对象有两个作用： 可以获取到上传文件的所有信息，比如：文件名、大小、类型、文件流数据 可以直接将文件写到服务器 part.write(“文件保存的路径”); Apache Commons Fileupload 上传方式用fileupload上传的核心就是：一个接口、两个类接口： FileItem 封装了我们表单中的每个域的数据（可能是普通文本数据，也可能是上传的文件） 类： DiskFileItemFactory： 用于创建文件上传对象的工厂 ServletFileupload： 文件上传对象 具体操作步骤 需要添加依赖： commons-fileupload.jar、commons-io.jar 新建处理文件上传的Servlet，然后重写doPost方法 调用ServletFileupload对象的静态方法，判断请求是否是一个文件上传请求 123if(!ServletFileupload.isMultipartContent(request)) &#123; // 如果不是multipart请求，代表不是一个有效的文件上传请求， 下面的步骤都可以省略了&#125; 创建文件上传工厂对象： 12DiskFileItemFactory factory = new DiskFileItemFactory();// factory.set.... 可以设置相关参数 创建文件上传对象 12ServletFileupload upload = new ServletFileupload(factory);// upload.set.... 可以设置相关参数 用文件上传对象解析请求对象，然后获取解析后的所有FileItem 1List&lt;FileItem&gt; fileItems = upload.parseRequest(request); 迭代处理每个FileItem 文本信息的FileItem获取后进行相关的业务操作 文件类型的FileItem获取后，调用FileItem.write将文件写到服务器某个目录下。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo搭建教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP]]></title>
    <url>%2F2019%2F09%2F16%2FJSP%2F</url>
    <content type="text"><![CDATA[[TOC] JSP &amp; EL &amp; JSTLJSP基础知识 JSP全称Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。 什么是jsp 从用户角度看待 ，就是是一个网页 ， 从程序员角度看待 ， 其实是一个java类， 它继承了servlet，所以可以直接说jsp 就是一个Servlet. 为什么会有jsp? html 多数情况下用来显示静态内容 ， 一成不变的。 但是有时候我们需要在网页上显示一些动态数据， 比如： 查询所有的学生信息， 根据姓名去查询具体某个学生。 这些动作都需要去查询数据库，然后在网页上显示。 html是不支持写java代码 ， jsp里面可以写java代码。 动态网页 所谓的动态网页，是指跟静态网页相对的一种网页编程技术。静态网页，随着html代码的生成，页面的内容和显示效果就基本上不会发生变化了——除非你修改页面代码。而动态网页则不然，页面代码虽然没有变，但是显示的内容却是可以随着时间、环境或者数据库操作的结果而发生改变的。 不要将动态网页和页面内容是否有动感混为一谈。这里说的动态网页，与网页上的各种动画、滚动字幕等视觉上的动态效果没有直接关系，动态网页也可以是纯文字内容的，也可以是包含各种动画的内容，这些只是网页具体内容的表现形式，无论网页是否具有动态效果，只要是采用了动态网站技术生成的网页都可以称为动态网页。 页面结构JSP声明变量、方法123456789&lt;%! private int age = 0; public void sayHello() &#123; out.println("Hello World!"); &#125; %&gt; JSP表达式1&lt;%=age %&gt; Java代码片段123456&lt;%age = age + 10;sayHello();%&gt; JSP注释 语法 描述 &lt;%– 注释 –%&gt; JSP注释，注释内容不会被发送至浏览器甚至不会被编译 HTML注释，通过浏览器查看网页源代码时可以看见注释内容 &lt;% 代表静态 &lt;%常量 %\&gt; 代表静态 %&gt; 常量 \‘ 在属性中使用的单引号 \“ 在属性中使用的双引号 JSP生命周期 编译阶段 当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。 解析JSP文件 将JSP文件转为Servlet 编译Servlet文件 初始化阶段 加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法 123// 可以重写此方法，添加初始化逻辑public void _jspInit() &#123;&#125; 执行阶段 调用与JSP对应的servlet实例的服务方法 12345public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)throws java.io.IOException, javax.servlet.ServletException &#123; // 分发请求 // doGet // doPost&#125; 销毁阶段 调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例 123// 可以重写此方法，添加销毁操作public void _jspDestroy() &#123;&#125; 三大JSP指令指令写法&lt;%@ 指令名字 属性名=”属性值” %&gt; page指令 language 表明jsp页面中可以写java代码 contentType 其实即使说这个文件是什么类型，告诉浏览器我是什么内容类型，以及使用什么编码 1&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; pageEncoding jsp内容编码 extends 用于指定jsp翻译成java文件后，继承的父类是谁，一般不用改。 注意：如果指定了此属性， 要继承的这个父类必须继承默认的HttpJspBase（因为Java只能继承一个类），否则JSP页面无法运行 import 导包使用的，一般不用手写。 session 值可选的有true or false . 用于控制在这个jsp页面里面，能够直接使用session对象。 具体的区别是，请看翻译后的java文件 如果该值是true , 那么在代码里面会有getSession（）的调用，如果是false : 那么就不会有该方法调用，也就是没有session对象了。在页面上自然也就不能使用session了。 errorPage 指的是错误的页面， 值需要给错误的页面路径 isErrorPage 上面的errorPage 用于指定错误的时候跑到哪一个页面去。 那么这个isErroPage , 就是声明某一个页面到底是不是错误的页面。 include指令 包含另外一个jsp的内容进来。 1&lt;%@ include file=&quot;other02.jsp&quot;%&gt; 背后细节: 把另外一个页面的所有内容拿过来一起输出。 所有的标签元素都包含进来。 taglib作用：用于引入标签库 语法：&lt;%@ taglib prefix=”” uri=””%&gt; 12uri: 标签库路径prefix : 标签库的别名 JSP 动作标签使用语法： 1&lt;jsp:动作标签名称 属性1="属性值" [属性2="属性值" 属性2="属性值"... ] /&gt; jsp:include1&lt;jsp:include page="other02.jsp"&gt;&lt;/jsp:include&gt; 包含指定的页面， 这里是动态包含。 也就是不把包含的页面所有元素标签全部拿过来输出，而是把它的运行结果拿过来。 jsp:forward123456789101112131415&lt;!-- 不带参数跳转 --&gt;&lt;jsp:forward page="test.jsp"&gt;&lt;/jsp:forward&gt;&lt;jsp:forward page="test.jsp" /&gt;&lt;!-- 带参数跳转 --&gt;&lt;!-- 中文参数会出现乱码，因为底层是通过URIEncoding来编码的，默认取的是request.getCharsetEncoding() , 要解决此乱码问题，我们需要再跳转前设置 request.setCharsetEncoding("UTF-8");--&gt;&lt;% request.setCharsetEncoding("UTF-8"); %&gt;&lt;jsp:forward page="test.jsp"&gt; &lt;jsp:param name="sname" value="zhangsan" /&gt;&lt;/jsp:forward&gt;&lt;!-- 如果这样写，中间必须加上param子标签 --&gt;&lt;jsp:forward page="test.jsp"&gt;&lt;/jsp:forward&gt; 前往哪一个页面。 jsp:param 意思是： 在包含某个页面的时候，或者在跳转某个页面的时候，加入这个参数。 123456789&lt;jsp:forward page="other02.jsp"&gt; &lt;jsp:param value="beijing" name="address"/&gt;&lt;/jsp:forward&gt;在other02.jsp中获取参数&lt;br&gt;收到的参数是：&lt;br&gt;&lt;%= request.getParameter("address")%&gt; ————————————————————————重点 jsp:useBean&amp;jsp:setProperty&amp;jsp:getProperty这组动作标签用于实例化JavaBean，并且设置、获取属性 123&lt;jsp:useBean id="stu" class="com.lanou3g.demo.bean.Student" /&gt;&lt;jsp:setProperty name="stu" property="sname" value="张三" /&gt;&lt;jsp:getProperty property="sname" name="stu"/&gt; JSP九大内置对象 所谓内置对象，就是我们可以直接在jsp页面中使用这些对象。 不用创建。 pageContext 【javax.servlet.jsp.PageContext】主要作用有两个： 获取其他内置对象 作为作用域，范围：当前页面 方法名 说明 forward 重定向到另一页面或Servlet组件 getAttribute 获取某范围中指定名字的属性值 findAttribute 按范围搜索指定名字的属性 removeAttribute 删除某范围中指定名字的属性 setAttribute 设定某范围中指定名字的属性值 getException 返回当前异常对象 getRequest 返回当前请求对象 getResponse 返回当前响应对象 getServletConfig 返回当前页面的ServletConfig对象 getServletContext 返回所有页面共享的ServletContext对象 getSession 返回当前页面的会话对象 request 【javax.servlet.http.HttpServletRequest】 作用：向服务端请求数据 方法名 说明 isUserInRole 判断认证后的用户是否属于某一成员组 getAttribute 获取指定属性的值,如该属性值不存在返回Null getAttributeNames 获取所有属性名的集合 getCookies 获取所有Cookie对象 getCharacterEncoding 获取请求的字符编码方式 getContentLength 返回请求正文的长度,如不确定返回-1 getHeader 获取指定名字报头值 getHeaders 获取指定名字报头的所有值,一个枚举 getHeaderNames 获取所有报头的名字,一个枚举 getInputStream 返回请求输入流,获取请求中的数据 getMethod 获取客户端向服务器端传送数据的方法 getParameter 获取指定名字参数值 getParameterNames 获取所有参数的名字,一个枚举 getParameterValues 获取指定名字参数的所有值 getProtocol 获取客户端向服务器端传送数据的协议名称 getQueryString 获取以get方法向服务器传送的查询字符串 getRequestURI 获取发出请求字符串的客户端地址 getRemoteAddr 获取客户端的IP地址 getRemoteHost 获取客户端的名字 getSession 获取和请求相关的会话 getServerName 获取服务器的名字 getServerPath 获取客户端请求文件的路径 getServerPort 获取服务器的端口号 removeAttribute 删除请求中的一个属性 setAttribute 设置指定名字参数值 session 【javax.servlet.http.HttpSession】 作用：用来保存每个用户的信息,以便跟踪每个用户的操作状态 方法名 说明 getAttribute 获取指定名字的属性 getAttributeNames 获取session中全部属性名字,一个枚举 getCreationTime 返回session的创建时间 getId 获取会话标识符 getLastAccessedTime 返回最后发送请求的时间 getMaxInactiveInterval 返回session对象的生存时间单位千分之一秒 invalidate 销毁session对象 isNew 每个请求是否会产生新的session对象 removeAttribute 删除指定名字的属性 setAttribute 设定指定名字的属性值 application 【javax.servlet.ServletContext】 作用：对应ServletContext对象， 在整个应用的生命周期内共享数据 方法名 说明 getAttribute 获取应用对象中指定名字的属性值 getAttributeNames 获取应用对象中所有属性的名字,一个枚举 getInitParameter 返回应用对象中指定名字的初始参数值 getServletInfo 返回Servlet编译器中当前版本信息 setAttribute 设置应用对象中指定名字的属性值 out 【javax.servlet.jsp.JspWriter】 作用：向客户端输出数据 方法名 说明 print或println 输出数据 newLine 输出换行字符 flush 输出缓冲区数据 close 关闭输出流 clear 清除缓冲区中数据,但不输出到客户端 clearBuffer 清除缓冲区中数据,输出到客户端 getBufferSize 获得缓冲区大小 getRemaining 获得缓冲区中没有被占用的空间 isAutoFlush 是否为自动输出 response 【javax.servlet.http.HttpServletResponse】 作用：封装了jsp产生的响应,然后被发送到客户端以响应客户的请求 方法名 说明 addCookie 添加一个Cookie对象 addHeader 添加Http文件指定名字头信息 containsHeader 判断指定名字Http文件头信息是否存在 encodeURL 使用sessionid封装URL flushBuffer 强制把当前缓冲区内容发送到客户端 getBufferSize 返回缓冲区大小 getOutputStream 返回到客户端的输出流对象 sendError 向客户端发送错误信息 sendRedirect 把响应发送到另一个位置进行处理 setContentType 设置响应的MIME类型 setHeader 设置指定名字的Http文件头信息 exception 【java.lang.Throwable】 被调用的错误页面的结果,只有在错误页面中才可使用, 即在页面指令中设置:&lt;%@page isErrorPage=“true”%&gt; page 【java.lang.Object】 它代表JSP被编译成Servlet,可以使用它来调用Servlet类中所定义的方法 config 【javax.servlet.ServletConfig】 作用：表示Servlet的配置,当一个Servlet初始化时,容器把某些信息通过此对象传递给这个Servlet 方法名 说明 getServletContext 返回所执行的Servlet的环境对象 getServletName 返回所执行的Servlet的名字 getInitParameter 返回指定名字的初始参数值 getInitParameterNames 返回该JSP中所有的初始参数名,一个枚举 四个作用域 表示这些对象可以存值，他们的取值范围有限定。 setAttribute 和 getAttribute 使用作用域来存储数据123456&lt;%pageContext.setAttribute("name", "page");request.setAttribute("name", "request");session.setAttribute("name", "session");application.setAttribute("name", "application");%&gt; 取出四个作用域中的值1234&lt;%=pageContext.getAttribute("name")%&gt;&lt;%=request.getAttribute("name")%&gt;&lt;%=session.getAttribute("name")%&gt;&lt;%=application.getAttribute("name")%&gt; 作用域范围大小： pageContext – request — session – application 四个作用域的区别 pageContext 【PageContext】 作用域仅限于当前的页面。 除了可以存储数据， 还可以获取其他8个内置对象 request 【HttpServletRequest】 作用域仅限于一次请求， 只要服务器对该请求做出了响应。 这个域中存的值就没有了。 session 【HttpSession】 作用域限于一次会话（多次请求与响应） 当中。 application 【ServletContext】 整个工程都可以访问， 服务器关闭后就不能访问了。 EL表达式 是为了简化咱们的jsp代码，具体一点就是为了简化在jsp里面写的那些java代码。 语法结构 ${expression } 从指定的作用域取参数 ${requestScope.表达式} 如果从作用域中取值，会先从小的作用域开始取，如果没有，就往下一个作用域取。 一直把四个作用域取完都没有， 就没有显示。 如何使用 取出4个作用域中存放的值。 1234567891011121314151617181920&lt;%pageContext.setAttribute("name", "page");request.setAttribute("name", "request");session.setAttribute("name", "session");application.setAttribute("name", "application");%&gt;按普通手段取值&lt;br&gt;&lt;%= pageContext.getAttribute("name")%&gt;&lt;%= request.getAttribute("name")%&gt;&lt;%= session.getAttribute("name")%&gt;&lt;%= application.getAttribute("name")%&gt;&lt;br&gt;使用EL表达式取出作用域中的值&lt;br&gt;$&#123; pageScope.name &#125;$&#123; requestScope.name &#125;$&#123; sessionScope.name &#125;$&#123; applicationScope.name &#125; 如果域中所存的是数组 12345678&lt;%String[] a = &#123;"aa","bb","cc","dd"&#125;;pageContext.setAttribute("array", a);%&gt; 使用EL表达式取出作用域中数组的值&lt;br&gt;$&#123;array[0] &#125; , $&#123;array[1] &#125;,$&#123;array[2] &#125;,$&#123;array[3] &#125; 如果域中锁存的是集合 123456789101112&lt;%List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("aa");list.add("bb");list.add("cc");list.add("dd");pageContext.setAttribute("li", list);%&gt;使用EL表达式取出作用域中集合的值&lt;br&gt;$&#123;list[0] &#125; , $&#123;li[1] &#125;,$&#123;li[2] &#125;,$&#123;li[3] &#125; 取出Map集合的值 1234567891011121314&lt;%Map map = new HashMap();map.put("name", "zhangsna");map.put("age",18);map.put("address","北京..");map.put("address.aa","深圳..");pageContext.setAttribute("map", map);%&gt;使用EL表达式取出作用域中Map的值&lt;br&gt;&lt;!-- map的key中有特殊字符时，我们必须用[]这种方式来获取值 --&gt;$&#123;map.name &#125; , $&#123;map.age &#125; , $&#123;map.address &#125; , $&#123;map["address.aa"] &#125; EL表达式 的11个内置对象。${ 对象名.成员 } pageContext 作用域相关对象 pageScope requestScope sessionScope applicationScope 头信息相关对象 header headerValues 参数信息相关对象 param paramValues cookie 全局初始化参数 initParam JSTL 全称 ： JSP Standard Tag Library jsp标准标签库 简化jsp的代码编写。 替换 &lt;%%&gt; 写法。 一般与EL表达式配合 怎么使用 导入jar文件到工程的WebContent/Web-Inf/lib jstl.jar standard.jar 在jsp页面上，使用taglib 指令，来引入标签库 比如引入JSTL核心标签库 1&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; 注意： 如果想支持 EL表达式，那么引入的标签库必须选择1.1以上的版本，1.0的版本不支持EL表达式。 JSTL标签分类核心标签(最核心、最重用)1&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; 表达式控制标签 out 属性名 含义 是否必须 value 输出值，如果是常量直接赋值， 如果是变量需要通过EL表达式取值 是 default 当value为null时， 输出default属性配置的值 否 escapeXml 是否转义XML特殊字符，取值true/false， 默认是true 否 set 属性名 含义 是否必须 value 搭配var属性使用，设置变量的值；搭配property和target使用，设置javabean属性的值 是 var 定义的变量名称 否 scope 变量保存到的作用域，默认是pageContext 否 target 给javabean设置属性，指定那个javabean。需配合&lt;jsp:useBean&gt;标签和property、value属性使用 否 property 设置javabean的哪个属性的值 否 remove 属性名 含义 是否必须 var 删除指定的变量，只能删除变量，不能删除javabean的属性 是 catch 属性名 含义 是否必须 var 存储错误信息 是 123456&lt;%-- &lt;c:catch&gt;用于包裹其他容易出错的标签，比如 --%&gt;&lt;c:catch var="error"&gt; &lt;!-- aa为没有实例化的javabean --&gt; &lt;c:set target="aa" property="name" value="zhangsan" /&gt;&lt;/c:catch&gt;&lt;c:out value="$&#123;error&#125;" /&gt; 流程控制标签 if 12345&lt;c:if test="$&#123;income &gt; 8000&#125;" var="ret"&gt; &lt;p&gt;My income is: &lt;c:out value="$&#123;income&#125;"/&gt;&lt;p&gt; &lt;/c:if&gt;&lt;!-- var属性ret存储的是test运算的结果 --&gt;$&#123;ret&#125; choose&amp;when&amp;otherwise 1234567891011&lt;c:choose&gt; &lt;c:when test="$&#123;income &lt;= 1000&#125;"&gt; Income is not good. &lt;/c:when&gt; &lt;c:when test="$&#123;income &gt; 10000&#125;"&gt; Income is very good. &lt;/c:when&gt; &lt;c:otherwise&gt; Income is undetermined... &lt;/c:otherwise&gt; &lt;/c:choose&gt; forEach 123456789101112131415161718192021222324252627282930313233343536&lt;% List&lt;String&gt; students = new ArrayList&lt;&gt;(); students.add("张三"); students.add("李四"); students.add("王五"); students.add("赵六"); request.setAttribute("stus", students);%&gt;&lt;!-- forEach遍历全部元素 --&gt;&lt;c:forEach var="stu" items="$&#123;stus&#125;"&gt; &lt;c:out value="$&#123;stu&#125;" /&gt; &lt;br /&gt;&lt;/c:forEach&gt;&lt;!-- forEach遍历部分元素 --&gt;&lt;c:forEach var="stu" items="$&#123;stus&#125;" begin="1" end="3"&gt; &lt;c:out value="$&#123;stu&#125;" /&gt; &lt;br /&gt;&lt;/c:forEach&gt;&lt;!-- forEach遍历部分元素，指定步长 --&gt;&lt;c:forEach var="stu" items="$&#123;stus&#125;" begin="1" step="2"&gt; &lt;c:out value="$&#123;stu&#125;" /&gt; &lt;br /&gt;&lt;/c:forEach&gt;&lt;!-- 用法四：部分遍历并带状态 --&gt;&lt;c:forEach var="stu" items="$&#123;stus&#125;" begin="1" end="3" varStatus="status"&gt;&lt;c:out value="$&#123;stu&#125;——四个属性："&gt;&lt;/c:out&gt;&lt;br&gt;&lt;c:out value="index属性：$&#123;status.index&#125;"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;c:out value="count属性：$&#123;status.count&#125;"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;c:out value="first属性：$&#123;status.first&#125;"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;c:out value="last属性：$&#123;status.last&#125;"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;c:out value="----------"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;/c:forEach&gt;&lt;!-- varStatus变量的几个属性：index从0开始；count从1开始；first是否第一个（boolean）；last是否最后一个（boolean）。 --&gt; forTokens 12345&lt;c:forTokens items="zhangsan,lisi,wangwu" delims="," var="item"&gt; &lt;c:out value="$&#123;item&#125;" /&gt; &lt;br /&gt;&lt;/c:forTokens&gt;&lt;!-- 另外forTokens也支持begin、end、step、varStatus几个属性，用法和forEach一样 --&gt; URL操作标签 url 12345&lt;c:url value="http://localhost:8080/Test/index.jsp" var="newUrl" scope="session"&gt; &lt;c:param name="username"&gt;zhangsan&lt;/c:param&gt; &lt;c:param name="password"&gt;a123456&lt;/c:param&gt;&lt;/c:url&gt;&lt;a href="$&#123;newUrl&#125;"&gt;New URL&lt;/a&gt; redirect 1234&lt;c:redirect url="www.baidu.com"&gt; &lt;c:param name="username"&gt;zhangsan&lt;/c:param&gt; &lt;c:param name="password"&gt;a123456&lt;/c:param&gt;&lt;/c:redirect&gt; param 一般作为其他标签的子标签使用，为其附加参数 格式化标签1&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt; 格式化时间 12345&lt;% Date date = new Date(); pageContext.setAttribute("d", date);%&gt;&lt;fmt:formatDate value="$&#123;d &#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt; 格式化数字 12345678&lt;% double d1 = 3.5; double d2 = 4.4; pageContext.setAttribute("d1", d1); pageContext.setAttribute("d2", d2);%&gt;&lt;fmt:formatNumber value="$&#123;d1 &#125;" pattern="0.00"/&gt;&lt;br/&gt;&lt;fmt:formatNumber value="$&#123;d2 &#125;" pattern="#.##"/&gt; SQL标签1&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/sql" prefix="sql"%&gt; setDataSource 123&lt;sql:setDataSource var="db" driver="com.mysql.jdbc.Driver" url="jdbc:mysql://localhost/test" user="root" password="1234"/&gt; query 123&lt;sql:query dataSource="$&#123;db&#125;" var="rs"&gt; SELECT * from Students; &lt;/sql:query&gt; update 123&lt;sql:update dataSource="$&#123;db&#125;" var="count"&gt; INSERT INTO Students VALUES (154,'Nasreen', 'jaha', 25); &lt;/sql:update&gt; param &amp; dateParam 123456789&lt;%Date DoB = new Date("2000/10/16");int studentId = 151;%&gt;&lt;sql:update dataSource="$&#123;db&#125;" var="count"&gt; UPDATE Student SET dob = ? WHERE Id = ? &lt;sql:dateParam value="&lt;%=DoB%&gt;" type="DATE" /&gt; &lt;sql:param value="&lt;%=studentId%&gt;" /&gt;&lt;/sql:update&gt; transaction 123456789101112&lt;sql:transaction dataSource="$&#123;db&#125;"&gt; &lt;sql:update var="count"&gt; UPDATE Student SET First_Name = 'Suraj' WHERE Id = 150 &lt;/sql:update&gt; &lt;sql:update var="count"&gt; UPDATE Student SET Last_Name= 'Saifi' WHERE Id = 153 &lt;/sql:update&gt; &lt;sql:update var="count"&gt; INSERT INTO Student VALUES (154,'Supriya', 'Jaiswal', '1995/10/6'); &lt;/sql:update&gt; &lt;/sql:transaction&gt; XML标签用的不多，这里不在列举 ps: 更多详细内容，参见：https://www.javatpoint.com/jstl 总结： JSP 三大指令 page include taglib 六个动作标签 &lt;jsp:include&gt; &lt;jsp:forward&gt; &lt;jsp:param&gt;​ jsp:useBean ​ jsp:setProperty ​ jsp:getProperty 九个内置对象 四个作用域 pageContext request session application out exception response page config ​ EL ${ 表达式 } 取4个作用域中的值 1$&#123; name &#125; 有11个内置对象。 123456789101112131415pageContextpageScoperequestScopesessionScopeapplicationScopeheaderheaderValuesparamparamValuescookieinitParam JSTL 使用1.1的版本， 支持EL表达式， 1.0不支持EL表达式 拷贝jar包， 通过taglib 去引入标签库 123&lt;c:set&gt;&lt;c:if&gt;&lt;c:forEach&gt; JSP Include指令和Include动作标签的区别 Include指令在代码编译之前就已经将两个页面的内容合并到一起，Include动作标签在运行期才会将页面做合并。 两种方式都可以实现将多个网页合并到一起 ​]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo搭建教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建过程]]></title>
    <url>%2F2019%2F09%2F09%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[环境准备1.Git下载安装2.Node.JS下载安装安装完成后，要确认是否已经安装成功，在cmd中使用下列命令来验证，有返回的信息就表示安装成功了 git –version node -v npm -v 安装Hexo 在git bash中输入 npm install -g hexo-cli 因为npm默认是从国外的源获取和下载包信息，所以这个命令有时候执行很慢，甚至可能因为被墙导致无法正常安装hexo，安装失败的话建议启用科学上网或百度搜索npm加速方法解决 安装成功后的信息显示如下： 初始化Hexo安装hexo完成后，在电脑中任意位置创建一个文件夹，名字可以随意取，这个文件夹就是存放hexo站点和以后写博客的地方，进入刚刚创建的文件夹，在空白位置右键选择Git Bash Here， 执行初始化hexo的命令 hexo init 初始化完成过程如下： 安装依赖包 npm install 这个命令是用来安装一些Node.js 模块。命令执行的结果如下： git部署安装 npm install hexo-deployer-git –save 完成这一步，hexo的安装就已经完成了。进入站点文件夹查看内容如下： 注意： hexo相关命令均在站点目录下执行，用Git Bash运行 站点配置文件为站点目录下的 _config.yml文件，可以配置大部分的参数 package.json 存放着应用程序的信息，默认已安装EJS, Stylus 和 Markdown renderer等软件 scaffold 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改 source 资源文件夹。是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 themes 主题文件夹，hexo会根据主题来生成静态页面，主题配置文件为主题文件夹下的_config.yml文件 本地预览Hexo博客第一次使用hexo，可以先在本地创建服务器使用 hexo generate # 生成静态页面 //可以直接用hexo g 命令 hexo s # 开启本地服务器 执行情况如下： 接下来到浏览器输入 localhost:4000 就可以看到页面内容了： 至此，Hexo博客已经成功搭建在本地了 部署Hexo博客github准备 首先要有一个github帐号，注册并登录github 然后新建一个仓库， 仓库名为：&lt;Github账号名称&gt;.github.io 将本地Hexo博客推送到新建的github仓库内本教程使用http协议部署hexo博客 修改配置文件blog/_config.yml，修改deploy项的内容（在文件末尾）。 1234deploy: type: git repo: https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：每个标签冒号后面都要有一个空格 输入以下命令将hexo博客部署到github中，返回INFO Deploy done: git即成功推送 hexo clean # 清空静态页面 hexo generate # 生成静态页面 hexo deploy # 上传到仓库 等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io，自此，Hexo博客已经搭建到了github上 在Hexo博客中发布文章新建一篇文章 在hexo博客目录下，进入Git Bash命令窗口，输入以下命令： hexo new “Article” 进入博客目录下的/source/_posts/ 文件夹，可以看到已经生成了名为Article.md的博客文件 如图所示： 打开Article.md文件，进行编辑即可 给文章添加分类和标签在打开的Article.md中，可以看到开头已经自动生成了一段配置列表，在其中设置tags和categories属性： 123456title: Articledate: 2019-09-07 20:46:51tags:- 博客- hexocategories: 测试 添加阅读全文按钮 方法一： 在文章任意你想添加的位置添加如下标签即可 1&lt;!-- more--&gt; 例如jQuery总结.md里的内容是： ---title: Articledate: 2019-09-07 20:46:51tags:- 博客- hexocategories: web前端---## 如何引入jQuery**jQuery本质上就是一段普通的JavaScript代码， 通常使用引入外部JS的方式来使用jQuery**```&lt;script type=&quot;text/javascript&quot; src=“js/jquery.js”&gt;&lt;/script&gt;```&lt;!--more--&gt;以下是正文内容，在首页预览内不显示 在网页上显示的效果是： 方法二： 打开主题配置文件，找到auto_excerpt进行如下修改 123auto_excerpt: enable: true length: 150 length为摘要截取的字符长度 注：这两张方向显示的方法显示的样式不一样，可以都尝试一下选择喜欢的方式进行添加 在文章中插入图片 方法一： 在hexo目录下，安装插件 npm install hexo-asset-image –save 在hexo\source目录下新建一个img文件夹，把图片放置在里面 在xxx.md文件中引用图片 1![header]( img/header.jpg) 方法二： 在全局配置文件hexo/_config.yml中将post_asset_folder设置为true 创建文章（在创建的时候，会在hexo/source/_post目录下，生成一个XXX.md文件和一个XXX的文件夹） 把XXX这个博文需要展示的图片放在XXX文件夹目录下 在XXX.md文件中引入图片的方式 1&#123;% asset_img example.jpg This is an example image %&#125; 方法三： 使用图床工具（本教程中插入的所有图片都是使用sm.ms提供的免费图床服务） 进入sm.ms网站，首页就是上传图片区域，选择要上传的图片点击Upload按钮，底部即会自动生成各种格式的图片链接，复制Markdown专用的链接，粘贴到文章中即可显示图片 启动服务器，在本地进行测试 hexo s 发布文章到github上待发布的文章在本地预览无误后，在Git Bash窗口执行以下命令 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 在浏览器访问网址： https://&lt;Github账号名称&gt;.github.io，即可看到已经发布的文章]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo搭建教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery总结]]></title>
    <url>%2F2019%2F09%2F07%2FjQuery%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[jQuery基础如何引入jQueryjQuery本质上就是一段普通的JavaScript代码， 通常使用引入外部JS的方式来使用jQuery 1&lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt; 基础语法基础语法： $(selector).action() 美元符号定义 jQuery 选择符（selector）”查询”和”查找” HTML 元素 jQuery 的 action() 执行对元素的操作 实例: $(this).hide() - 隐藏当前元素 $(“p”).hide() - 隐藏所有 元素 $(“p.test”).hide() - 隐藏所有 class=”test” 的 元素 $(“#test”).hide() - 隐藏所有 id=”test” 的元素 选择器1$(slector) selector就是选择器表达式，语法基本和CSS选择器一致 示例： $(“#container”) $(“.container”) $(“img”) $(“input[type=’password’]”) $(“#container image”) HTML操作DOM操作jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易 属性操作attr()：用于获取属性值 读取属性 12345$(selector).attr(attrName);//示例var href = $("a").attr("href");var id = $("div").attr("id"); 修改属性 1234$(selector).attr(attrName, "属性值");//示例var href = $("a").attr("href", "http://www.jd.com"); 属性名不仅支持标准属性，还支持自定义属性 内容操作获得内容 text()：设置或返回所选元素的文本内容 html()：设置或返回所选元素的内容（包括 HTML 标记 val()：设置或返回表单字段的值 1234567891011//通过 jQuery text() 和 html() 方法获得内容:$("#btn1").click(function()&#123; alert("Text: " + $("#test").text());&#125;);$("#btn2").click(function()&#123; alert("HTML: " + $("#test").html());&#125;);//通过 jQuery val() 方法获得输入字段的值：$("#btn1").click(function()&#123; alert("值为: " + $("#test").val());&#125;); 样式操作通过 jQuery，可以很容易地对 CSS 元素进行操作 addClass() - 向被选元素添加一个或多个类 1234$("button").click(function()&#123; $("h1,h2,p").addClass("blue"); $("div").addClass("important");&#125;); removeClass() - 从被选元素删除一个或多个类 123$(&quot;button&quot;).click(function()&#123; $(&quot;h1,h2,p&quot;).removeClass(&quot;blue&quot;);&#125;); toggleClass() - 对被选元素进行添加/删除类的切换操作 123$("button").click(function()&#123; $("h1,h2,p").toggleClass("blue");&#125;); css() - 设置或返回样式属性 设置css属性 1$("p").css("background-color","yellow"); 返回css属性 1$("p").css("background-color"); 事件 鼠标事件 键盘事件 表单事件 文档/窗口事件 click keypress submit load dblclick keydown change resize mouseenter keyup focus scroll mouseleave blur unload hover 效果显示隐藏通过 jQuery使用hide()和show() 方法来隐藏和显示 HTML 元素 123456789101112131415//例：&lt;script&gt; $(document).ready(function()&#123; $("#hide").click(function()&#123; $("p").hide(); &#125;); $("#show").click(function()&#123; $("p").show(); &#125;);&#125;);&lt;/script&gt;&lt;p&gt;如果你点击“隐藏” 按钮，我将会消失。&lt;/p&gt;&lt;button id="hide"&gt;隐藏&lt;/button&gt;&lt;button id="show"&gt;显示&lt;/button&gt; 使用 toggle() 方法来切换 hide() 和 show()方法 123$("button").click(function()&#123; $("p").toggle();&#125;); 淡入淡出fadeIn()方法：用于淡入已隐藏的元素 12345$("button").click(function()&#123; $("#div1").fadeIn(); $("#div2").fadeIn("slow"); $("#div3").fadeIn(3000);&#125;); fadeOut()方法：用于淡出可见元素 12345$("button").click(function()&#123; $("#div1").fadeOut(); $("#div2").fadeOut("slow"); $("#div3").fadeOut(3000);&#125;); fadeToogle()方法：可以在 fadeIn() 与 fadeOut() 方法之间进行切换 12345$("button").click(function()&#123; $("#div1").fadeToggle(); $("#div2").fadeToggle("slow"); $("#div3").fadeToggle(3000);&#125;); fadeTo()方法：允许渐变为给定的不透明度（值介于 0 与 1 之间） 12345$("button").click(function()&#123; $("#div1").fadeTo("slow",0.15); $("#div2").fadeTo("slow",0.4); $("#div3").fadeTo("slow",0.7);&#125;); 滑动slideDown()方法：用于向下滑动元素 123$("#flip").click(function()&#123; $("#panel").slideDown();&#125;); slideUp()方法：用于向上滑动元素 123$("#flip").click(function()&#123; $("#panel").slideUp();&#125;); slideToggle()方法：可以在 slideDown() 与 slideUp() 方法之间进行切换 123$("#flip").click(function()&#123; $("#panel").slideToggle();&#125;); 动画使用jQuery animate() 方法可以创建自定义的动画 遍历遍历jQuery对象遍历数组for...in循环语句用于遍历数组或者对象的属性进行循环操作 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作 1234567891011121314151617//语法for (变量 in 对象)&#123; 在此执行代码&#125;//例&lt;script type="text/javascript"&gt; var x var mycars = new Array() mycars[0] = "Saab" mycars[1] = "Volvo" mycars[2] = "BMW" for (x in mycars)&#123; document.write(mycars[x] + "&lt;br /&gt;") &#125;&lt;/script&gt; AjaxjQuery也可以实现异步加载]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript总结]]></title>
    <url>%2F2019%2F09%2F07%2FJavaScript%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JavaScript基础如何引入JavaScript外联文件1&lt;script src="引入的文件位置（本地文件位置或者远程链接）"&gt;&lt;/script&gt; 内联文件123&lt;script type="text/javascript"&gt; js代码编写的位置&lt;/script&gt; Js输出语句用于基本的调试： 123document.write() //向body中写入字符串console.log() //向控制台输出alert() //弹出框 基础语法 语句分号（ ；）结尾，大括号包裹语句块（基本与Java语法类似） 严格区分大小写 没有添加分号时浏览器自动添加，但是消耗资源并且可能添加出错 注释Hbuilder快捷键 Ctrl + / 添加注释** 单行注释：// 多行注释：/* */ JavaScript基本数据类型​ JavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等 Number Js中只有一种数值类型Number Js中的Number可以表示十进制，八进制，十六进制整数，浮点数，科学记数法 Js中的Number基本类型可以精确表示的最大整数是2^53，BigInt可以表述任意大的整数 String 字符串被引号包围。可以使用单引号或双引号 Boolean 布尔值只有两个值 true false，经常用在条件测试中 undefined 表示声明了但未赋值的变量，其值是 undefined ，typeof 也返回 undefined 1234//已经声明的变量未赋值则成为undefined var a; console.log(typeof a);//结果为undefined 任何变量均可通过设置值为 undefined 进行清空。其类型也将是 undefined 空值与 undefined 不是一回事，空的字符串变量既有值也有类型。 1var car = ""; // 值是 ""，类型是 "string" null null表示一个对象不存在，其数据类型为Object 1234//表示一个空对象 var a = null; console.log(typeof a);//结果为object Object Function Function是一个功能完整的对象，作为JS的内置对象之一。JS的普通函数都是Function对象的实例，所以函数本身也是一个对象，就像var一样，只不过这个对象具有可调用特征而已。 function只是一个关键字，用来创建一个普通函数或对象的构造函数。 RegExp RegExp 对象是带有预定义属性和方法的正则表达式对象 正则表达式，在 JavaScript 中，正则表达式常用于两个字符串方法：search() 和 replace() 12search() //使用表达式来搜索匹配，然后返回匹配的位置。replace() //返回模式被替换处修改后的字符串。 正则表达式修饰符 123i //执行对大小写不敏感的匹配g //执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）m //执行多行匹配 Date 日期对象是一个静态的对象，计算机时间会不断变化，但日期对象不会 new Date() 用当前日期和时间创建新的日期对象，参数可以填year, month, ...，用于指定日期和时间创建新的日期对象 1var d = new Date(2018, 11, 24, 10, 33, 30, 0); //变量分别为年、月、日、小时、分钟、秒和毫秒 JSON JSON对象语法 1&#123; "name":"Nya", "age":21, "car":null &#125; JSON 对象被花括号{}包围 JSON对象以键/值对的方式书写 键必须是字符串，值必须是有效的 JSON 数据类型（字符串、数字、对象、数组、布尔或 null） 键和值由冒号分隔 每个键/值对由逗号分隔 访问JSON对象值 使用点（.）访问对象JSON值 12myObj = &#123; "name":"Nya", "age":21, "car":null &#125;;x = myObj.name; 也可以使用户方括号（[]）访问JSON对象值 12myObj = &#123; "name":"Nya", "age":21, "car":null &#125;;x = myObj["name"]; 遍历JSON对象 使用for-in遍历JSON对象 1234myObj = &#123; "name":"Nya", "age":21, "car":null &#125;;for (x in myObj)&#123; document.getElementById("demo").innerHtml += myObj[x];&#125; 对于嵌套的JSON对象，使用点号和括号访问嵌套的JSON对象 12345678910/***实例***/myObj = &#123; "name":"Bill Gates", "age":62, "cars": &#123; "car1":"Porsche", "car2":"BMW", "car3":"Volvo" &#125;&#125; 1234/***访问方法***/x = myObj.cars.car2;//或者：x = myObj.cars["car2"]; 修改值 也是使用点号或括号来修改JSON对象中的任意值 12myObj.cars.car3 = "Mercedes Benz"; //使用点号myObj.cars["car3"] = "Mercedes Benz"; //使用括号 删除对象属性 使用delete删除JSON对象的属性1delete myObj.cars.car1; ​ typeof 操作符的注意点： typeof 是操作符，不是方法。虽然我们经常使用 typeof() 的方式获取对象的数据类型 对 null 取 typeof 是 object（这是因为 null 是 空的对象引用），对函数取 typeof 是 function 123456console.log(typeof null); //返回objectfunction demo()&#123; console.log('demo'); &#125; console.log(typeof demo); // 返回function JavaScript变量JavaScript 变量是存储数据值的容器，作用和Java里的变量类似 其声明形式不需要指定具体类型，统一用var关键字声明 123var x = 7;var y = 8;var z = x + y; Js标识符：所有JavaScript变量必须以唯一的名称标识。这些唯一的名称称为标识符，标识符命名规则与java基本一致 JavaScript 变量可存放多种数据类型： ​ 字符串被包围在双引号或单引号中。数值不用引号。如果把数值放在引号中，会被视作文本字符串。 程序控制语句条件语句用来执行逻辑判断的语句 条件判断语句 123456789var a = 1;if(a = 1)&#123; console.log("A");&#125;else&#123; console.log("B"); if(a != 5)｛ console.log("C"); ｝&#125; 条件分支语句 123456789101112var a = 1; switch(a)&#123; case 1: console.log("1"); break; case 2: console.log("2"); break; default: console.log("其他"); break; &#125; 循环语句使代码能在某种条件下不断执行的语句 for循环 12345678910111213/**语法**/for(初始化变量; 条件表达式; 更新变量)&#123; 语句...&#125; /**例**/function p(i)&#123; document.write(i); document.write("&lt;br&gt;");&#125;for(var i = 0; i &lt; 10; i++)&#123; p(i);&#125; for…in循环： 用于对数组或者对象的属性进行循环操作 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作 1234567891011121314/**语法**/for (变量 in 对象)&#123; 执行代码...&#125;/**例**/var xvar mycars = new Array()mycars[0] = "Saab"mycars[1] = "Volvo"mycars[2] = "BMW"for (x in mycars)&#123; document.write(mycars[x] + "&lt;br /&gt;")&#125; 对象自定义对象 使用new关键字创建对象 12345var person = new Person();person.name = "Nya";person.age = 21;person.sex = "男";//创建了对象的一个新实例，并向其添加了四个属性 new所调用的函数是一个构造函数constructor()，构造函数是专门用来创建对象的函数，使用typeof语句会返回object 通过function设计一个对象 12345678910//创建函数构造器function person(name, age, sex)&#123; this.name = name; this.age = age; this.sex = sex //在JS中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象（运行时）&#125;//创建对象实例var myFather = new person("Ton", 51, "男");var myMother = new person("Sally", 49, "女"); 构造函数内部也可以定义方法 使用JSON创建对象 –-详见数据类型一节-– JS内置对象Window对象 Document对象 Document对象包含当前文档的信息，例如：标题、背景、颜色、表格等 常用方法： 通过write()方法在浏览器中显示内容 getElementById()和getElementByTagName()，这两个方法会忽略文档的结构，可查找整个HTML文档中的任何元素（不论它们在文档中所处的位置，例如通过getElementByTagName()可以把文档中所有的元素找到） cookie方法会返回一个包含所有的cookie的字符串，每条cookie以分号和空格(; )分隔(即key*=*value键值对)： 1allCookies = document.cookie; body方法会返回道歉文档中的&lt;body&gt;元素或者&lt;frameset&gt;元素 Screen对象 window.screen对象在编写时可以不使用 window 这个前缀 一些属性： screen.availWidth - 可用的屏幕宽度 1document.write("可用宽度: " + screen.availWidth); screen.availHeight - 可用的屏幕高度 1document.write("可用高度: " + screen.availHeight); Location对象 location.href 属性 12345//改变当前网页地址（加载新的网页）：location.href = 'http://www.baidu.com';//返回（当前页面的)整个URL：document.write(location.href); History对象 一些方法： history.back() 123456&lt;input type="button" value="Back" onclick="goBack()"&gt;&lt;script&gt; function goBack()&#123; window.history.back() &#125;&lt;/script&gt; 以上代码效果为返回上一页按钮 history.forward() 123456&lt;input type="button" value="Forward" onclick="goForward()"&gt;&lt;script&gt; function goBack()&#123; window.history.forwardk() &#125;&lt;/script&gt; 以上代码效果为跳到下一页按钮 函数JavaScript函数语法1234function functionname( 参数.../*可选*/ )&#123; // 执行代码&#125;//注：JavaScript 对大小写敏感。关键词 function 必须是小写的，并且必须以与函数名称相同的大小写来调用函数 ​ 当调用该函数时，会执行函数内的代码。 ​ 可以在某事件发生时直接调用函数（比如当用户点击按钮时），并且可由 JavaScript 在任何位置进行调用。 获取函数参数 常规方式 通过内置arguments对象获取 自调用函数函数表达式可以 “自调用”，自调用表达式会自动调用。 如果表达式后面紧跟 () ，则会自动调用。 不能自调用声明的函数。 通过添加括号，来说明它是一个函数表达式 1234(function () &#123; var x = "Hello!!"; // 我将调用自己&#125;)();//以上函数实际上是一个匿名自我调用的函数(没有函数名) JavaScript的使用场景添加交互事件​ 对事件做出反应 ​ 可以在事件发生时执行 JavaScript，比如当用户在 HTML 元素上点击时 1&lt;h1 onclick=&quot;this.innerHTML=&apos;Ooops!&apos;&quot;&gt;点击文本!&lt;/h1&gt; 操作DOM元素​ 可以使用JavaScript 来向HTML DOM元素分配事件： 12//例：向button元素分配onclick事件：document.getElementById("myBtn").onclick=function()&#123;displayDate()&#125;; 操作样式​ JavaScript操作style样式 1234//语法dom.style.属性名 = 属性值;//例如：document.getElementsByClassName('box')[0].style.background = 'red'; 验证表单 必填（或必选项目） JavaScript可以用来检查用户是否已填写表达中的必填（或必选）项目。假如必填或必选项为空，那么警告框会弹出 1234567891011121314&lt;form name="myForm" action="demo-form.php" onsubmit="return validateForm()" method="post"&gt;姓: &lt;input type="text" name="fname"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt;function validateForm()&#123; var x=document.forms["myForm"]["fname"].value; if (x==null || x=="") &#123; alert("姓必须填写"); return false; &#125;&#125; Email验证 检查输入的数据是否符合电子邮件地址的基本语法，只能做些基本检查： 输入的数据必须包含 @ 符号和点号(.)。同时，@ 不可以是邮件地址的首字符，并且 @ 之后需有至少一个点号 1234567891011121314&lt;form name="myForm" action="demo-form.php" onsubmit="return validateForm();" method="post"&gt; Email: &lt;input type="text" name="email"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;function validateForm()&#123; var x=document.forms["myForm"]["email"].value; var atpos=x.indexOf("@"); var dotpos=x.lastIndexOf("."); if (atpos&lt;1 || dotpos&lt;atpos+2 || dotpos+2&gt;=x.length)&#123; alert("不是一个有效的 e-mail 地址"); return false; &#125;&#125; 异步请求Ajax请求： 同步请求:只有当一次请求完全结束以后才能够发起另一次请求 异步请求:不需要其他请求结束就可以向服务器发起请求 Ajax：Asynchronous javaScript and xml (异步的JavaScript和xml技术)。 当我们向服务器发起请求的时候，服务器不会像浏览器响应整个页面，而是只有局部刷新。它是一个异步请求，浏览器页面只需要进行局部刷新，效率非常的高 正则匹配 详见上文正则部分 定时器js 定时器有以下两个方法： setInterval不停地重复执行，按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭 使用形式：函数setInterval(函数名, 重复执行的时间间隔毫秒数 ); 12345678910111213141516171819&lt;script&gt;function printTime()&#123; var d = new Date(); var h= d.getHours(); var m= d.getMinutes(); var s= d.getSeconds(); document.getElementById("time").innerHTML= h+":"+m+":"+s;&#125;function showTimeIn3Seconds()&#123; setTimeout(printTime,3000); &#125;&lt;/script&gt;&lt;div id="time"&gt;&lt;/div&gt;&lt;button onclick="showTimeIn3Seconds()"&gt;点击后3秒钟后显示当前时间，并且只显示一次&lt;/button&gt;/**通过setInterval**重复执行同一个函数**，重复的时间间隔由第二个参数指定**/ setTimeout在指定的毫秒数后调用函数或计算表达式 使用形式：函数setTimeout(functionname, 距离开始时间毫秒数 ); 123456789101112131415161718//例：每隔1秒钟，打印当前时间&lt;script&gt;function printTime()&#123; var d = new Date(); var h= d.getHours(); var m= d.getMinutes(); var s= d.getSeconds(); document.getElementById("time").innerHTML= h+":"+m+":"+s;&#125;var t = setInterval(printTime,1000);&lt;/script&gt;&lt;div id="time"&gt;&lt;/div&gt;/**document.getElementById 获取id=time的div元素 .innerHTML 修改该元素的内容**/ 事件事件是JavaScript允许HTML与用户交互的行为。 用户任何对网页的操作，都会产生一个事件 onchange HTML元素改变事件123456789//例：离开输入字段时，会触发一个函数，将输入文本转换为大写&lt;script&gt;function myFunction() &#123; var x = document.getElementById("fname"); x.value = x.value.toUpperCase();&#125;&lt;/script&gt;请输入您的名字：&lt;input type="text" id="fname" onchange="myFunction()"&gt; onclick 鼠标点击事件12345678//例：点击按钮弹出“Hello JavaScript”&lt;script&gt;function showHello()&#123; alert("Hello JavaScript");&#125;&lt;/script&gt;&lt;button onclick="showHello()"&gt;点击一下&lt;/button&gt; onbluronblur 事件会在对象失去焦点时发生 12345678910//例：离开输入框后会将文本转化为大写&lt;script type="text/javascript"&gt;function upperCase()&#123; var x=document.getElementById("fname").value document.getElementById("fname").value=x.toUpperCase()&#125;&lt;/script&gt;输入您的姓名：&lt;input type="text" id="fname" onblur="upperCase()" /&gt; onmouseover / onmouseout12345678910111213//例：鼠标移入移出事件&lt;script&gt;function mOver(obj) &#123; obj.innerHTML = "谢谢您"&#125;function mOut(obj) &#123; obj.innerHTML = "请把鼠标移上来"&#125;&lt;/script&gt;&lt;div onmouseover="mOver(this)" onmouseout="mOut(this)" style="background-color:#D94A38;width:120px;height:20px;padding:40px;"&gt; 请把鼠标移上来&lt;/div&gt; onload1234567891011121314//onload事件&lt;script&gt;function checkCookies() &#123; var text = ""; if (navigator.cookieEnabled == true) &#123; text = "Cookie 已启用"; &#125; else &#123; text = "Cookie 未启用"; &#125; document.getElementById("demo").innerHTML = text;&#125;&lt;/script&gt;&lt;p id="demo"&gt;&lt;/p&gt; onkeydown键盘按下事件]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
