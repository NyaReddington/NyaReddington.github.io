<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[白日梦想家]]></title>
    <url>%2Fbv%2Ffde%2F</url>
    <content type="text"><![CDATA[今天看了一部非常治愈也很触动人心的佳作，得知这部电影的存在是在一个非常奇妙的巧合下，所以被它深深地吸引到了，提前准备好影片，在这个珍贵的周末下午开始了观赏。《白日梦想家》，起初看到电影名称以为会讲述一个游手好闲、终日做着白日梦的人物经历的故事，直到看完全片才发现是这一个充满冒险的旅行故事，也是一场追求真爱的爱情故事。 作为一部冒险公路片，电影的画面可以说是美轮美奂，导演高超的技艺让观众感受到了一个无比美好的世界，与主角日复一日的枯燥生活形成了鲜明的对比，如同真实与虚幻的交织，冰原、大海、喜马拉雅山，每一个场景都让人充满了想立即出发去旅行的冲动。 此外，影片里的角色形象也是相当地鲜明，沃尔特·密提是一名在《生活》杂志工作了16年的胶片洗印经理，他日复一日地过着单调乏味的生活，内心却充满了对英雄梦的渴望。面对生活，沃尔特像个旁观者，时常“走神”做白日英雄梦，面对心仪的同事他也迟迟不敢上前搭讪。他性格内向，但他心仪的同事谢莉尔确是一个独立自信的女性角色。这些角色形象不仅揭示了人性的弱点和缺陷，也展现了人类对于梦想和爱情的执着追求。 在情节设计上，这部影片同样精彩绝伦。沃尔特为了寻找摄影师肖恩，踏上了一场惊心动魄的冒险旅程。在这个过程中，他不仅一步步追上了摄影师的神秘踪迹，更一步步地克服了自己内心的恐惧和不安。故事的中间有一个细节，沃尔特在踏上旅途时背上的旅行用具，都是二十年前准备欧洲旅行时候就买好的，只是那时没有勇气走出第一步，但他背上儿时的旅行包，用儿时的旅行笔记本写下了成年的足迹，这种自我觉醒与成长的历程让人感到无比的真实。故事的最后，经历了蜕变的沃尔特赢得了心仪同事的欣赏，并且发现了摄影师所说的最美的照片竟是自己认真工作的样子，原来我们一直在追求最美好的事务，却发现认真做一件事的样子才是最美的。 焦虑不安的我们，应该要明白，一部激励人心的电影，一场说走就走的旅行，这些事情都不会立刻拯救我们的生活，我们只需认真的生活和工作，去发现并享受生命中每一个美好的时刻，正如摄影师肖恩送给沃尔特的钱包上所言：看见世界，身临其境贴近彼此，感受生活，这就是生活的目的所在。]]></content>
      <categories>
        <category>观后感</category>
      </categories>
      <tags>
        <tag>Movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《玩转Vim 从放弃到爱不释手》学习笔记]]></title>
    <url>%2Fbv%2Fbd69%2F</url>
    <content type="text"><![CDATA[本篇是b站up主PegasusWang老师的玩转Vim 从放弃到爱不释手教程笔记，在大学的时候使用过vim，但只是停留非常低级的操作阶段，也在其他地方零散的学习过Vim，直到在b站发现了PegasusWang的视频，非常不错，是目前看到过最好的vim入门教程，经过几天的学习，Vim已经近乎熟练，再次感谢PegasusWang的无私奉献，笔记还会持续更新。 Vim编辑器的四种模式Normal(普通)模式使用vim打开文件时显示的模式，只可以查看，不可以做任何编辑操作 进行所有操作之后可以单击u(undo)来撤销操作 移动操作w/W 移到下一-个word/WORD开头。e/E 下一个word/WORD尾 b/B 回到上一-个word/WORD开头，可以理解为backword word指的是以非空白符分割的单词，WORD以空白符分割的单词 搜索操作同一行快速移动的方式其实是搜索一个字符并且移动到该字符 f{char} 可以把光标移动到当前行的char字符上，t把光标移动到char的前一个字符 如果第一次没搜到，可以用分号;和逗号,继续搜该行里的下一个/上一个char字符 大写的F{char}表示反过来搜前面的字符 快速移动到一行的行首或者行尾0 移动到行首第一个字符，^移动到第一个非空白字符 $ 移动到行尾，g_ 移动到行尾非空白字符 记住常用的0和$就可以满足日常需求了 页面移动gg / G 移动到文件开头和结尾，你可以使用ctrl+o快速返回 H / M / L 跳转到屏幕的开头(Head)，中间(Middle)和结尾(Lower) Ctrl+u / ctrl+f 上下翻页 (upword/forward) zz 把当前光标放置到屏幕置中间 删除操作x 快速删除一个字符 dw delete word：快速删除一个单词 dd 快速删除当前整行内容 修改操作常用有三个，r (replace) ， c (change) ，s(substitute) r可以替换一个字，s替换并进入插入模式 cw *change word：** 快速删除一个单词并且进入编辑模式 查询操作/ 或者 ? 进行前向或者反向搜索 n / N 跳转到下一个或者上一个匹配 Normal下的复制粘贴复制剪切分别使用y(yank)和p(put)，剪切用d 我们可以使用v(visual)命令进入可视模式选中所要复制的地方，然后使用p粘贴 配合文本对象：比如使用yw复制一个单词， yy复制一行 编辑/插入模式普通模式下单击以下字母进入编辑/插入模式 i insert： 在当前光标位置前面开始插入 I insert before line： 光标调到当前行最前面开始插入 a *append： *在当前光标位置后面开始插入 A append after line： 光标跳到当前行最后面开始插入 o open a line below： 在当前光标所在行下面新加一行开始插入 O open a line above： 在当前光标所在行上面新加一行开始插入 按Esc可以退出编辑模式进入普通模式，我在.vimrc里配置了jj映射来方便地进入普通模式 快捷键gi 快速返回上一次编辑的位置 终端中和vim插入模式下都可以使用的快捷键：ctrl+h 删除上一个字符 ctrl+w 删除上一个单词 ctrl+u 删除当前行 ctrl+a 移动到开头 ctrl+e 移动到结尾 ctrl+b 往前移动 ctrl+f 往后移动 命令模式普通模式下单击冒号:进入命令模式 保存退出方式:q quite 退出 :w write 写入/保存 :wq write &amp; quite 保存然后退出 ZZ 作用等同于:wq :e! 禁止刚刚所有修改 多文件操作Buffer、Window、Tab区别： Buffer是指打开的一个文件的内存缓冲区 Vim打开一个文件后会加载文件内容到缓冲区 之后的修改都是针对内存中的缓冲区,并不会直接保存到文件 直到我们执行:w (write)的时候才会把修改内容写入到文件里 Window是Buffer可视化的分割区域 一个缓冲区可以分割成多个窗口, 每个窗口也可以打开不同缓冲区 每个窗口可以继续被无限分割(看你屏幕是否够大) Tab可以组织窗口为一-个工作区. Vim的Tab和其他编辑器不太一样，可以想象成Linux的虚拟桌面 比如一个Tab全用来编辑Python文件，一个Tab全是HTML文件 相比窗口，Tab一般用的比较少，Tab太多管理起来也比较麻烦 打开多个Buffer(缓冲区)： 使用:e {文件名}可以打开多个文件，这时虽然只有一个窗口，但是却有多个Buffer(缓冲区) 在Buffer(缓冲区)之间切换： 使用:ls会列举当前缓冲区，然后使用:b n跳转到第n个缓冲区 使用:bpre :bnext :bfirst :blast来跳转到 上一个/下一个/第一个/最后一个 缓冲区 或者用:b {buffe名称}加上tab补全来跳转缓冲区 分割Window(窗口)命令： &lt;Ctrl+w&gt;+s或:sp水平分割 &lt;Ctrl+w&gt;+v或:vs垂直分割，:q 来退出分屏 使用:sp {文件路径}或:vs {文件路径}可以在横竖分屏时直接打开指定的文件 在Window(窗口)之间切换： &lt;Ctrl+w&gt;+w 在窗口间循环切换 &lt;Ctrl+w&gt;+h 切换到左边的窗口 &lt;Ctrl+w&gt;+j 切换到下边的窗口 &lt;Ctrl+w&gt;+k 切换到上边的窗口 &lt;Ctrl+w&gt;+l 切换到右边的窗口 可以使用:q /:wq来关闭分屏 切换窗口快捷键就是vim内上下左右对应的k j h l方向键，记住j是下就好 将切换窗口的方向快捷键改为大写效果是移动窗口 在不同窗口编辑同一个Buffer，所有的Buffer都会生效，因为都是编辑的同一块内存里的内容 替换操作substitute命令允许我们查找并且替换掉文本，并且支持正则式 :[range]s[ubstitute]/{pattern}/{string}/[flags] range 表示范围，比如：10, 20表示10-20行，%表示全部 s substitute：表示替换 pattern 是要替换的文本，string 是替换后文本 flage 是替换标志，一般有： g global：表示全局范围内执行 c confirm：表示确认，可以确认或者拒绝修改 n number：报告匹配到的次数而不替换，可以用来查询某个单词出现的次数，例如：:% s/java//n (因为是查询所以java后面留空) 例如： :% s/java/python/g 表示在整个文件内把“java”替换为“python”，%：所有文件 s：替换 g：全局替换 解决粘贴缩进混乱的操作:set paste 保留原格式粘贴，先执行该命令，再按i进入编辑模式粘贴就会保留原文件格式 :set nopaste 关闭粘贴命令 h paste 显示粘贴命令帮助，:exit退出帮助 其他操作:set nu 显示行号 :% s/java/python/g 全局替换字符，把“java”替换为“python” %：所有文件 s：替换 g：全局替换 Visual(可视)模式v 进入VISUAL选择模式，会选中当前字符，左右移动光标可以连续选中左右字符，上下移动光标会选中整行字符 V 选中当前行，上下移动光标可以连续选中上下整行字符 ctrl + v 进入VISUAL BLOCK：列选择/块选择模式，用于列编辑 在visual模式下： y yank：复制 d 剪切 p put：粘贴 dd 删除一行 yy 复制一行 给vim更换配色使用普通命令方式更换第三方配色以hybrid主题为例，先在用户根目录下clone好主题的仓库 1git clone https://github.com/w0ng/vim-hybrid.git 然后在用户根目录下创建.vim/colors文件夹，如果没有.vim文件夹需要先创建好.vim文件夹 12mkdir ~/.vimmkdir ~/.vim/colors 接着把hybird主题文件夹内的Vim主题文件拷贝到刚创建好的colors文件夹内 1cp vim-hybrid/colors/hybrid.vim ./.vim/colors 最后用Vim任意打开一个文件，键入:colorscheme，敲一个空格后按ctrl+d，就可以看到Vim可以更换的所有主题配色了 接着输入你想更换的配色的名字，点击回车，可以看到vim编辑器的配色就被成功更改了 这种方式不能持久化的更改vim编辑器的配色 Vim配置文件的使用Vim里非常多常用的设置，比如:set number设置行号，之前的使用都是在Vim里临时设置，没法持久化，每次都要重新设置 但是Vim还提供了一种持久化配置的方式，使用.vimrc配置文件，让我们自定义配置 新建Vim配置文件Linux/Unix下新建一个隐藏文件 1vim ~/.vimrc 接着我们就可以开始自定义自己的配置了 Vimrc配置文件的内容配置文件内需要设置的东西有以下四种： 常用设置，我们可以把常用的设置写到.vimrc内避免每次打卡爱vim重新设置，比如： set number 设置行号，colorscheme xxx 设置主题 Vim内有非常多这种配置，可以参考别人的配置，常用的有： 12345678910" 设置行号set number" 设置主题colorscheme hybrid" 按F2进入粘贴模式set pastetoggle=&lt;F2&gt;" 高亮搜索set hlsearch" 设置折叠方式set foldmethod=indent Vim映射配置，Vim中的映射比较复杂，源于Vim有多种模式 设置一下leader键let mapleader = ‘,’常用的是逗号或空格 比如noremap &lt;leader&gt;w :w&lt;cr&gt;保存文件 在下面映射章节有详细讲解Vim中的映射概念和常用的映射配置 插件的配置，现代化的Vim可以通过插件管理器安装插件 通过插件可以无限扩充Vim的功能 使用插件需要具备一定的Vim配置知识 在下面插件章节有详细讲解如何安装和使用常用插件 Vim脚本函数配置，Vim有可以自定义的脚本语言vimscript Vim脚本对于Vim高级玩家来说可以实现强大的vim插件 初学者知道有这个概念就好， vim脚本是一种简单的脚本语言 可以通过vimscript实现更多vim的控制，开发自己的插件 可以研究下github上vim-go教程vim-go-tutorial的vimrc文件 这个文件是使用vim写go语言的一个最小配置，基本涵盖了一个编程语言需要设置的选项，可以用来参考学习 通过把vimrc配置放到git版本备库管理，可以同步到其他电脑或者服务器上 Vim映射的使用Vim映射就是把「一个操作」映射到「另一个操作」 如果你不满现在的按键设置，比如vim本来的命令，或者你想映射一些方便的快捷键时，按照你的意愿定制Vim 基本映射基本映射指的是normal模式下的映射，当然还有其他模式的映射 使用map就可以实现映射。比如： map- x 表示按-就会删除字符 map &lt;space&gt; viw 表示按下空格的时候选中整个单词 map &lt;c-d&gt; dd 表示使用ctrl+d执行dd删除一行 模式映射Vim常用模式normal/visual/insert都可以定义映射 用nmap/vmap/imap定义映射只在normal/visual/insert分别有效，比如： :vmap \ U 表示把在visual模式下选中的文本用\转换大小写 (u/U转换大小写) :imap &lt;d-d&gt; &lt;Esc&gt;ddi 表示在insert模式下用ctrl+d删除一行 递归映射与非递归映射递归映射*map系列命令有递归的风险，例如定义了以下两个映射： :nmap \ - 和 :nmap - dd 当你按下\时, Vim会解释其为-，我们又映射了-，Vim会继续解析为dd，即它会删除整行，即有点类似于递归 通常情况是你安装了一个插件，插件映射了同一个按键的不同行为，有冲突就会有一个失效，解决方案就是使用非递归映射 非递归映射Vim提供了非递归映射,这些命令不会递归解释 使用*map对应的nnoremap/vnoremap/inoremap 「任何」时候都应该使用非递归映射，防止自己的命令和其他命令冲突 一些方便的映射以上的设置映射的命令都可以去掉冒号:持久化到.vimrc文件内，这里提供一些常用的映射配置： 12345678910111213141516171819" 把leader键映射为','let mapleader=',' " 使用 jj 进入 normal 模式inoremap jj &lt;Esc&gt;`^" 使用 leader+w 直接保存inoremap &lt;leader&gt;w &lt;Esc&gt;:W&lt;Cr&gt;noremap &lt;leader&gt;w :W&lt;cr&gt;" 切换buffernnoremap &lt;silent&gt; [b :bprevious&lt;CR&gt;nnoremap &lt;silent&gt; [n :bnext&lt;CR&gt;" 使用 ctrl+h/j/k/l 切换 windownoremap &lt;C-h&gt; &lt;C-w&gt;hnoremap &lt;C-j&gt; &lt;C-w&gt;jnoremap &lt;C-k&gt; &lt;C-w&gt;knoremap &lt;C-l&gt; &lt;C-w&gt;l" 使用 sudo 强制写入cnoremap w!! w !sudo tee % &gt;/dev/null" json格式化 这是命令模式下的映射com! FormatJSON %!python3 -m json. tool 可以研究下笨方法学Vimscript这本书中映射章节的内容 Vim插件的使用和其他现代流行编辑器一样, Vim同样支持强大的插件扩展 Vim 插件是使用vimscript或者其他语言编写的vim功能扩展，编辑器自带的功能有限，有了插件之后几乎可以无限制扩充其功能 网络上比如github.com等有很多开源的vim插件可以使用 插件的安装原始的方式是直接clone插件代码，如今vim有很多插件管理器可供选择，你可以选择一个顺手的使用 常见的有vim-plug,、Vundle、 Pathogen、Dein.Vim、volt等 综合性能、 易用性、文档等几个方面，这里推荐使用vim-plug vim-plug的安装进入vim-plug插件的github仓库：https://github.com/junegunn/vim-plug 根据文档内容，在终端输入命令安装vim-plug： 12curl -fLo ~/.vim/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 如果使用的是Neovim，则使用以下命令： 12curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim vim-plug的使用编写配置文件在.vimrc文件内写入一行call plug#begin()，指定插件安装的目录 然后在中间列出要安装的插件，格式为Plug &#39;xxx&#39;，注意插件名称前后必须使用单引号 最后在结尾加上一行call plug#end()就可以安装插件了 可以参考文档给出的示例进行编写： 123456789101112&quot; Specify a directory for plugins：指定一个插件目录&quot; - For Neovim: stdpath(&apos;data&apos;) . &apos;/plugged&apos;&quot; - Avoid using standard Vim directory names like &apos;plugin&apos;：避免使用标准的Vim目录名称，例如“插件”call plug#begin(&apos;~/.vim/plugged&apos;)&quot; Make sure you use single quotes：确保使用单引号&quot; 列出要安装的插件，例如：Plug &apos;mhinz/vim-startify&apos;&quot; Initialize plugin system：初始化插件系统call plug#end() 这里起作用的代码其实就三行：call plug#begin(&#39;~/.vim/plugged&#39;)、Plug &#39;mhinz/vim-startify&#39;和call plug#end() 安装第一个vim插件我们将安装vim-startify，一个好用的vim开屏插件：vim-startify 根据仓库内的文档教程，修改你的.vimrc文件，增加该插件名称：Plug &#39;mhinz/vim-startify&#39; 重新启动Vim或者使用:source ~/.vimrc ，然后执行:PlugInstall就可以开始安装插件了 安装完成后，回到终端重新启动vim就可以看到该插件的效果了，其他插件的安装方式也都类似 Vim插件网站：https://vimawesome.com/]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux非root用户 Oh My ZSH 使用攻略]]></title>
    <url>%2Fbv%2Fe207%2F</url>
    <content type="text"><![CDATA[由于oh-my-zsh相关文件是每个用户独有的，不是所有用户共用一份的，在服务器上给root用户配好了oh-my-zsh，但大部分时候要用非root用户操作，用惯了oh-my-zsh，没有这个很难受，打算给自己普通用户也安装一个，搜了很多教程折腾了一晚才配好了，遇到不少问题，打算记录一下。 安装ZSH 下载解压源码。因为直接apt or yum都需要sudo，所以得下源码编译安装 12345## 下载源码wget -O zsh.tar.xz https://sourceforge.net/projects/zsh/files/latest/download## 解压xz -d zsh.tar.xz ## 解压xz文件，提示xz命令不存在的话安装一下xztar -xvf zsh.tar ## 解压tar文件 配置和安装 123./configure --prefix=$HOME/usr/makemake install 第一条命令执行过程中可能会出现这个问题： 12&gt; configure: error: "No terminal handling library was found on your system. This is probably a library called curses or ncurses. You may need to install a package called 'curses-devel' or 'ncurses-devel' on your system"&gt; 原因是这个curses-devel或ncurses-devel没有安装，所以还需要找到其中一个的source code编译安装一下： Ubuntu可以使用libncurses5-dev替代ncurses-devel 12&gt; apt-get install libncurses5-dev&gt; CentOS直接安装ncurses-devel 12&gt; yum install ncurses-devel&gt; 第二步安装过程可能会因为系统没安装gcc或者make编译器而失败，根据提示安装相应编译器再回来操作 检查是否安装成功。运行下面命令看是否进入zsh shell 1~/usr/bin/zsh 测试无误后输入exit退出zsh 安装oh-my-zsh 运行安装脚本，如果你在此前尝试过安装Oh My Zsh，务必先删除：rm -rf ~/.oh-my-zsh 1sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 这一步操作时候如果提示Unable to establish SSL connection，先查看是否安装好了openssl，如果没用就尝试直接使用wget禁用SSL验证来获取这个install.sh文件： 123wget --no-check-certificate https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh## 然后使用以下命令运行该文件bash install.sh 如果这样操作提示没有权限运行/root下的/.oh-my-zsh，则是因为环境变量没有随用户切换而切换 解决办法是ctrl + d退回能最开始的用户，通过su -切换用户 1234su - 用户名## 查看一下echo $ZSH## 没有输出东西的话就可以接着运行bash install.sh命令了 su 用户 ：只切换身份 su - 用户 ：身份和shell（包含环境变量）都切换 无论你是怎样得到并运行install.sh的，只要得到下列结果就表明安装成功： 12345678910111213 __ __ ____ / /_ ____ ___ __ __ ____ _____/ /_ / __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \/ /_/ / / / / / / / / / / /_/ / / /_(__ ) / / /\____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at https://shop.planetargon.com. 运行exec $HOME/usr/bin/zsh检查是否正常 更改默认shell 因为没有root权限所以chsh用不了，只能修改.bashrc文件来实现功能，末尾追加已下语句 12# use zshexec $HOME/usr/bin/zsh 运行exec $HOME/usr/bin/zsh确认shell没问题，然后source ~/.bashrc 不然会导致直接断开ssh连接，而且重新ssh也会导致断开连接。 如果真出现ssh上不去的情况，可以运行下面代码试试： 123ssh -t username@hostname /bin/bash# 或者ssh username@hostname "bash --noprofile --norc" 之后恢复原来的.bashrc文件即可 参考链接： 没有 Root 权限 Oh My Zsh 使用攻略 Linux非root用户安装zsh和oh-my-zsh 安装oh-my-zsh报错could not create work tree dir ‘/root/.oh-my-zsh’.: Permission denied的原因&amp;解决办法]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>WSL</tag>
        <tag>Linux</tag>
        <tag>ZSH</tag>
        <tag>oh-my-zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用LxRunOffline自定义配置WSL，在Windows下拥有你的完美Linux子系统]]></title>
    <url>%2Fbv%2F555d%2F</url>
    <content type="text"><![CDATA[作为一名开发人员很多时候需要Linux环境，但是由于日常开发也不能抛弃Windows，双系统来回切换很是麻烦，用虚拟机又会有性能损耗，直到知道了WSL (Win­dows Sub­sys­tem for Linux) ，现在微软对WSL的支持越来越好，Hyper-v技术的使用使得在win10上运行Linux越来方便。 由于在Microsoft Stroe安装WSL的默认安装路径是系统盘，为了避免后期使用不撑爆系统盘，可以把WSL整个安装目录进行转移：使用wsl --export 和 wsl --import这两个命令对WLS进行打包再自定义目录安装。这本来基本是相当完美的解决方案了，但还有另外一款非常实用的WSL管理软件：LxRunOffline，它可以将任何Linux发行版本安装到任何目录上，备份、转移和恢复已安装的WSL目录，设置默认用户和修改环境变量等操作，总之就是非常牛牛，完全可以替代wsl、wslconfig这些原生的管理命令。 启用 WSL如果你没有使用过WSL，需要先做如下准备： 打开windows设置，搜索开发者设置，启用开发人员模式，如果不进行这步操作，之后可能不能使用LxRunOffline的命令 可以通过以下两种方式启用 WSL： 使用管理员权限打开 Powershell，执行 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 进入“控制面板”——双击“程序和功能”——点击左侧的“启用或关闭 Windows 功能”——勾中“适用于 Linux 的 Windows 子系统”——点击“确定”按钮。 下载 Linux发行版系统Docker 镜像CentOS系统下载方式 访问 CentOS 的官方 Docker 镜像网站：CentOS Cloud SIG image repository.； 切换到自己想要的分支，比如：CentOS-7-x86_64； 进入 docker 目录，下载centos-*-docker.tar.xz文件，比如：centos-7-x86_64-docker.tar.xz； Ubuntu系统下载方式 下载 WSL 官方离线包，改后缀名为，使用解压缩软件解压后可得到名为 install.tar.gz 的文件。 或者在 LxRunOffline WiKi 中下载大佬们提供的镜像文件。 安装 ChocolateyChocolatey 是 Win­dows 环境下的包管理器，其作用等同于 Mac OS 的 Brew，Ubuntu 的 apt，Cen­tOS 的 yum。具体的安装方法参见官方文档。在具有管理员权限的 Pow­er­shell 中执行下列命令： 1Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 安装 LxRunOffline与微软商店的安装方式不同，LxRunOf­fline 安装 WSL 更灵活，它可以安装任意发行版到任意目录，还可以自定义 WSL 名称。 继续在 Pow­er­shell 中执行下列命令： 1choco install LxRunOffline 使用 LxRunOffline 安装你的Linux发行版系统继续在 Pow­er­shell 中执行下列命令： 1LxRunOffline install -n &lt;WSL名称&gt; -d &lt;安装系统的路径&gt; -f &lt;镜像文件路径&gt;\xxx.tar.gz -s 其中： -n是安装的系统名称，可自定义； -d 是安装系统的目录； -f是之前下载的镜像文件路径； 另外加入-s参数可在桌面创建快捷方式，可以不加。 启动你的Linux发行版系统可以用以下方式启动： 原生启动WSL 查看已安装的发行版本 123wsl -l //列出当前已经安装的开发版wslconfig /list //列出当前已经安装且随时可用的发行版wslconfig /list /all //列出所有发行版，包括正在安装、卸载和已损坏的发行版 运行指定 WSL 1wsl -d &lt;WSL名称&gt; 设置默认 WSL 1wsl -s &lt;WSL名称&gt; 使用 LxRunOffline 运行 WSL和原生运行方式本质上是一样的。 创建快捷方式 使用微软应用商店安装的 WSL 会在开始菜单添加应用图标（快捷方式），而使用 LxRunOf­fline 安装 WSL 时可以通过添加 -s 参数在桌面创建快捷方式。如果你安装时忘记添加参数，可以使用以下命令进行创建。 1LxRunOffline s -n &lt;WSL名称&gt; -f &lt;快捷方式路径&gt;.lnk 使用命令运行指定 WSL 在有多个 WSL 的情况下，可以指定运行某个发行版。 1LxRunOffline run -n &lt;WSL名称&gt; 等同于wsl -d 设置默认 WSL 设置默认 WSL 后，可以在 cmd 和 powershell 中输入 wsl 直接调用默认的 WSL 。 1LxRunOffline sd -n &lt;WSL名称&gt; 等同于wsl -s 按照上述步骤，你就拥有了一个可以任意折腾的Linux子系统了。 使用 LxRunOffline 设置默认用户当修改过 WSL 的名称或目录后就无法通过微软官方提供的方法设置默认用户。这时可以使用 LxRunOf­fline 进行设置。 设置普通用户为默认用户使用 LxRunOf­fline 新安装的 WSL 默认是以 root 用户登录，如果你需要默认以普通用户进行登录，就需要进行下面的操作。 首先运行 WSL ，输入以下命令创建用户： 1useradd -m -s /bin/bash &lt;用户名&gt; 然后对该用户设置密码，输入命令后会提示输入两次密码。 1passwd &lt;用户名&gt; 授予该用户 sudo 权限。 1usermod -a -G sudo &lt;用户名&gt; 为了保持和微软商店安装的效果一致，这里提及的方法是把用户添加到 sudo 用户组。其他关于 sudo 权限的设置方法以及免密设置可参考《Linux 中授予普通用户 sudo 权限的正确方法》这篇文章。 查看用户 UID ，一般是 1000。 1id -u &lt;用户名&gt; 按 Ctrl+D 退出 WSL ，在 Pow­er­Shell 中输入以下命令： 1LxRunOffline su -n &lt;WSL名称&gt; -v 1000 设置 root 为默认用户root 用户的 UID 为 0，所以可以直接在 Pow­er­Shell 输入以下命令进行设置： 1LxRunOffline su -n &lt;WSL名称&gt; -v 0 使用 LxRunOffline 转移 WSL 安装目录LxRunOf­fline 可以对系统中已经安装的 WSL 进行目录转移操作，拯救爆满的 C 盘。 查看系统中已安装的 WSL 。 1LxRunOffline l 类似于wsl -l。LxRunOf­fline 不会显示默认 WSL ，查看默认 WSL 需要使用 lxrunoffline gd命令。 输入命令对 WSL 的目录进行移动。 1LxRunOffline m -n &lt;WSL名称&gt; -d &lt;路径&gt; 最后查看路径，进行确认。 1LxRunOffline di -n &lt;WSL名称&gt; 使用 LxRunOffline 备份和恢复 WSL使用 LxRunOf­fline 可以方便的对 WSL 进行备份和恢复，同样可以实现转移的操作，而且还可以在转移到其它电脑上。 备份 WSL查看系统中已安装的 WSL 。 1wsl -l 然后输入需要备份的 WSL 名称和备份的目标路径。 1LxRunOffline e -n &lt;WSL名称&gt; -f &lt;压缩包路径&gt;.tar.gz 类似但不等同于wsl --export &lt;压缩包路径&gt;.tar。LxRunOf­fline 备份完会生成一个.xml后缀的同名配置文件，比如WSL.tar.gz.xml。 恢复 WSL输入以下命令可以恢复已备份的 WSL，和安装是相同的命令。 1LxRunOffline i -n &lt;WSL名称&gt; -d &lt;安装路径&gt; -f &lt;压缩包路径&gt;.tar.gz 类似但不等同于wsl --import &lt;安装路径&gt; &lt;压缩包路径&gt;.tar。LxRunOf­fline 会读取备份时生成的配置文件并写入配置，前提是同目录且同名。否则你需要加入-c参数指定配置文件。 使用 LxRunOffline 修改 WSL 名称查看 WSL 名称。 1wsl -l 查看 WSL 安装目录。 1LxRunOffline di -n &lt;WSL名称&gt; 导出指定的 WSL 配置文件到目标路径。 1LxRunOffline ec -n &lt;WSL名称&gt; -f &lt;配置文件路径&gt;.xml 配置信息可以输入lxrunoffline sm -n查看 取消注册（这个操作不会删除目录） 1LxRunOffline ur -n &lt;WSL名称&gt; 使用新名称注册 1LxRunOffline rg -n &lt;WSL名称&gt; -d &lt;WSL路径&gt; -c &lt;配置文件路径&gt;.xml 卸载已安装的WSL原生卸载 1wslconfig /unregister &lt;wsl名称&gt; 使用 LxRunOffline 卸载WSL1LxRunOffline uninstall -n &lt;wsl名称&gt; 参考链接： LxRunOffline 使用教程 - WSL 自定义安装、备份 https://github.com/DDoSolitary/LxRunOffline]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>WSL</tag>
        <tag>Linux</tag>
        <tag>LxRunOffline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用MacType，让Windows的字体变得更漂亮]]></title>
    <url>%2Fbv%2Ffd42%2F</url>
    <content type="text"><![CDATA[改善win10字体渲染效果如何改善 Windows 的字体渲染是一个亘古不变的话题，长期以来大家都有这样的一个印象：Windows 上面的字体渲染相比 MacOS 没有那么细腻清晰，默认的字体时不时以点阵形式出现戳瞎双眼。 实际上，也确实是这个样子，由于 Windows 世界中参差不齐的硬件和向前兼容的「历史包袱」，Windows 新 UI 和新的渲染模式需要去兼容老旧的程序，往往也正是因为这些程序，给 Windows 用户「字体渲染模糊不清」的体验。 关于 MacTypeMacType 是由 FlyingSnow 延续 GDI++ 开源专案的字体渲染软体，直白的说就是替 Windows 的使用者在网页浏览、系统界面、一般程式中呈现更好看的字体显示效果，其能一直无障碍兼容到最近的 Windows 10 。MacType 给 Windows 用户带来了优良的字体显示效果，也使得我们能够「热替换」系统默认字体而无需修改系统文件。 诚如前面提到 MacType 是延续 GDI++ 开源专案而来，局限当然就是只能渲染 GDI+ 的程序。所以对 Windows 7 之后，采用微软开发的新字体渲染引擎 DirectWrite 方案的程序像是微软自己的 UWP APP、Office 系列程式一直没有直接的解决办法，最大众化的差异就体现在 Chrome 52 版拿掉禁止 DirectWrite 功能后，呈现出一片模糊的效果。但这在 Firefox 上不是问题。 软件下载建议去Github仓库Release页面下载最新版本软件 MacType下载地址： 官网：https://www.mactype.net/ Github：https://github.com/snowie2000/MacTypenoMeiryoUI下载地址： 官网：http://tatsu.life.coocan.jp/MySoft/WinCust/index.html Github：https://github.com/Tatsu-syo/noMeiryoUI 安装配置首先下载MacType，按照提示一步步安装即可，安装完成后打开会自动进入配置MacType有注册表、服务、MacTray托盘三种加载模式，建议使用MacTray托盘加载 -&gt; 独立加载模式方式下一步选择配置，这里我喜欢使用XMac中的XMac.LCD.Default配置。 下一步选择配置，这里我喜欢使用XMac中的XMac.LCD.Default配置 配置完成后，即可开始享受一个字体渲染愉快的 Windows 了。实际上 MacType 使用过程你会遇到各种毛病，如 一些软件不能渲 染，一些用宋体的软件渲染起来很难看，就需要替换系统的宋体。 修改系统字体运行noMeiryoUI，选择字体，设定全部 我这里推荐这个字体：Sarasa Gothic / 更纱黑体 / 更紗黑體 / 更紗ゴシック。更纱黑体是一个在 100% 缩放比例下同样有着优秀的显示效果的字体。在 这里 可以下载到最新的 ttf 字体，安装之后会得到几个字体，其中我们需要的就是「更纱黑体 UISC」，即「Sarasa UI SC」。（SC 代表 Simplified Chinese，简体中文。） 排除冲突进程需要注意的是，部分应用可能会与 MacType 渲染存在冲突（例如 MacType 会影响 Office 2016 的安装失败），这时我们需要使用通 过排除进程来使应用正常工作。 打开 MacType 安装目录下的 MacType.ini 中添加以下内容： 1234[UnloadDll]sample1.exesample2.exesample3.exe 将其中 sample*.exe 替换为所需排除的程序名即可。另外需要注意的是若使用「注册表加载模式」，配置文件的变更需要重启才能生效。 显示效果对比 改善Chrome字体渲染效果修改Chrome字体设置打开chrome，进入设置→外观→自定义字体 这里我是使用了Chrome推荐的字体设置插件Advanced Font Settings来修改的字体，在这里可以下载安装这个扩展程序Advanced Font Settings 是一个chrome扩展，按理来说浏览器或系统也有自己的字体设置，但是这个Advanced Font Settings更加贴心一点，它可以按照英文、中文等等分开设置。可以在这里了解该插件更多的内容。 此时将字体换为更纱黑体之后, 显示效果并不是很好，此时需要结合油猴插件质感字体&amp;&amp;页面平滑滚动增强字体的显示效果， 脚本安装地址：http://suo.im/61ZO1o 显示效果对比 参考链接： MacType 美化 Windows10 字体，体验类 Mac 顺滑字体 win10字体显示Mac效果+Chrome字体效果增强 Win10 Mactype 字体优化]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>MacType</tag>
        <tag>字体渲染</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA显示Run Dashboard窗口]]></title>
    <url>%2Fbv%2F290c%2F</url>
    <content type="text"><![CDATA[默认情况下，IDEA的Run Dashboard是关闭的，当检测到你有多个springboot项目时会弹出提示框，询问是否打开 但是如果没有提醒，就需要自己配置了： 方法一：工具栏中依次打开View-》Tool Windows-》Run Dashboard 如果上述的选项里没有Run Dashboard，使用方法二 方法二找到工程目录中.idea文件夹下的workspace.xml，打开，接下来找到 123456789101112&lt;component name="RunDashboard"&gt; &lt;option name="ruleStates"&gt; &lt;list&gt; &lt;RuleState&gt; &lt;option name="name" value="ConfigurationTypeDashboardGroupingRule" /&gt; &lt;/RuleState&gt; &lt;RuleState&gt; &lt;option name="name" value="StatusDashboardGroupingRule" /&gt; &lt;/RuleState&gt; &lt;/list&gt; &lt;/option&gt;&lt;/component&gt; 在其中加入一个如下的 12345678910111213141516171819&lt;component name="RunDashboard"&gt; &lt;!-- 加入此项 --&gt; &lt;option name="configurationTypes"&gt; &lt;set&gt; &lt;option value="SpringBootApplicationConfigurationType" /&gt; &lt;/set&gt; &lt;/option&gt; &lt;option name="ruleStates"&gt; &lt;list&gt; &lt;RuleState&gt; &lt;option name="name" value="ConfigurationTypeDashboardGroupingRule" /&gt; &lt;/RuleState&gt; &lt;RuleState&gt; &lt;option name="name" value="StatusDashboardGroupingRule" /&gt; &lt;/RuleState&gt; &lt;/list&gt; &lt;/option&gt;&lt;/component&gt; 重启项目，Run Dashboard窗口就会显示出来了]]></content>
      <categories>
        <category>错误解决</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX总结--JS原生Ajax & jQuery Ajax]]></title>
    <url>%2Fbv%2Fb570%2F</url>
    <content type="text"><![CDATA[原生Ajaxget请求流程 创建ajax请求对象： 大多数浏览器为XMLHTTPRequest()，高版本IE浏览器为ActiveXObject(&quot;Msxml2.XMLHTTP&quot;)，低版本IE浏览器为ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) 123456789101112131415161718function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Chrome, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer（高版本） xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e)&#123; try&#123;// Internet Explorer（低版本） xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; 使用open方法创建http请求，并设置请求地址 123456789101112131415//执行get请求function get() &#123; //1. 创建xmlhttprequest 对象 var xhr = ajaxFunction(); //2. 发送请求。 /* * 参数一： 请求类型 GET or POST * 参数二： 请求的路径 * 参数三： 是否异步， true or false */ xhr.open("GET" ,"TestServlet" ,true ); xhr.send();&#125; 如果发送请求的同时，还想获取数据，那么代码如下 12345678910111213141516171819202122//执行get请求function get() &#123; //1. 创建xmlhttprequest 对象 var xhr = ajaxFunction(); //2. 设置请求参数 xhr.open("GET" ,"TestServlet?name=aa&amp;age=18" ,true ); //3. 获取响应数据 注册监听的意思。 一会准备的状态发生了改变，那么就执行 = 号右边的方法 xhr.onreadystatechange = function()&#123; // readyState的值一共有5个状态，参见下表 // readyState == 4 表示请求已经完成， 再判断状态码是否是200，200表示服务端正常响应(没有报错) if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; //弹出响应的信息 alert(request.responseText); &#125; &#125; // 4. 发送请求 xhr.send();&#125; post请求流程Post请求方式和Get请求基本相同，只是由于post方式传递数据是模仿form表单传递给服务器的,要设置header头协议 12345678910111213141516171819202122232425262728//1. 创建对象// 和get请求一样function post() &#123; //1. 创建请求对象 var xhr = ajaxFunction(); // 2. 设置请求地址、参数、类型(post、get) xhr.open("post", "StudentServlet", true); //3. 获取响应数据 注册监听的意思。 一会准备的状态发生了改变，那么就执行 = 号右边的方法 xhr.onreadystatechange = function()&#123; //前半段表示 已经能够正常处理。 再判断状态码是否是200 if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; //弹出响应的信息 console.log("请求完成"); var h1 = document.getElementById("h1"); h1.innerHTML = xhr.responseText; &#125; &#125; // 4. 如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); // 5. 发送请求 // 如果是GET请求，参数写在这里是无效的 xhr.send("id=555");&#125; jQuery Ajax$.ajax()的使用该方法用于执行Ajax请求，常用于其他jQuery Ajax方法不能完成的请求，是jQuery中Ajax系列方法的的底层实现，其他方法都是在它的基础上给我们封装的更方便使用的方法。 形式：$.ajax(url, [settings]);常用字段： url：链接地址，字符串 type：“POST&quot;或 “GET&quot;，请求类型 data：需发送到服务器的数据，GET与POST都可以，格式为{A: ‘…’, B: ‘…’} dataType：服务器响应的数据类型，字符串表示；当填写为json时，回调函数中无需再对数据反序列化为json success：请求成功后，服务器回调的函数 error：请求失败后，服务器回调的函数 123456789101112131415$.ajax("TestServlet", &#123; type: "GET", data: &#123; action: "json", uname: "zhangsan" &#125;, dataType: "json", success: function(data, status_text)&#123; console.log(data); console.log("status_text: " + status_text); &#125;, error: function(xhr, textStatus, errorThrow) &#123; console.log("请求失败"); &#125;&#125;); $.get()的使用$.get()方法使用GET方式来进行异步请求，它的语法结构为： $.get(url, data, func, dataType); 123456789101112/* * 参数： * url: 请求地址 * data: 待发送 Key/value 参数 * fn: 请求成功后回调函数 * type: 返回内容格式，xml, html, script, json, text, _default */$.get( "url",&#123;pid:pid&#125; ,function(data,status_text)&#123; console.log(data); console.log("status_text: " + status_text);&#125;,"json" ); // 指定请求返回的格式是json，jquery会帮我们把服务端返回的json字符串转换成js的json对象 $.post()的使用$.post()方法使用POST方式来进行异步请求，它的语法结构为： $.post(url, data, function, dataType); 123456789101112/* * 参数： * url: 请求地址 * data: 待发送 Key/value 参数 * fn: 请求成功后回调函数 * type: 返回内容格式，xml, html, script, json, text, _default */$.post( "url",&#123;pid:pid&#125; ,function(data,status)&#123; console.log(data); console.log("status_text: " + status_text);&#125;,"json" ); // 指定请求返回的格式是json，jquery会帮我们把服务端返回的json字符串转换成js的json对象 $.getJSON();的使用$.getJSON()是专门为ajax获取json数据而设置的，该方法使用GET方式执行Ajax请求，从服务器加载JSON格式数据，并且支持跨域调用，它的语法结构为： $.getJSON(url, data, func); 因为确定服务器返回的是json编码的数据，所以相较于$.get()不用再指定dataType。 123$.getJSON("url", &#123;id:1, name: "zhangsan"&#125; function(json)&#123; console.log(json);&#125;); 以上四个方法的关系和区别？$.ajax()是jQuery的底层AJAX实现，$.get()和$.post()是简单易用的jQuery高层AJAX实现 $.getJSON()是通过 HTTP GET 请求载入 JSON 数据。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie & Session总结]]></title>
    <url>%2Fbv%2F3a88%2F</url>
    <content type="text"><![CDATA[CookieCookie是什么Cookie是一种能够让Web服务器把少量数据储存到客户端的硬盘或内存里，或是从客户端的硬盘里读取数据的一种技术。 为什么要使用Cookie因为HTTP协议是一种无状态协议，Http没有保存状态，对每一个请求无法区别每个请求对应的是哪个用户，也无法判定是否是用户已经登录或者是还没登录，所以需要引入一种机制，通过在浏览器中存储一些数据，记录用户的登录状态和保存用户的登录信 息；引入cookie之后，在请求时会把cookie附加到请求头中，这样服务端一读取请求头就知道了这次请求是哪个用户发起的。 什么情况下要使用CookieCookie的使用分为在业务程序中显式使用和通过容器隐式使用。 隐式使用： 首次访问JSP、Servlet时，Servlet容器会自动往响应头中添加一个Cookie(Tomcat中是JSESSIONID) 显式使用： 当我们有一些安全性要求不高，数据量不大的用户数据需要存储时，可以考虑使用Cookie 怎么使用Cookie?Cookie的属性 在Chrome浏览器开发者模式中，我们可以看到网站的cookie；图中可以看到Cookie具有的属性有 Name、value、Domain、path、Expires/Max-Age、Size、HTTP、Secure等。 Name：该Cookie的名称，一旦创建，名称便不可更改 Value：该Cookie的值，如果值为Unicode字符，需要为字符编码 Domain：可以访问到这个Cookie的域名。如果设置为.google.com,则所有以google.com结尾的域名都可以访问该 Cookie。注意第一个字符必须为. 注： 非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。 顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。 二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。 顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。 Path：可以访问到这个Cookie的页面路径。 比如domain是.goole.com, path是/TestServlet，那么只有/TestServlet 路径下的页面可以读取此Cookie。 Expires/Max-Age: 该Cookie失效时间，单位秒。Cookie在maxAge秒之后失效。 Size：此Cookie的大小。 HTTP：此cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。 Secure：设置是否只能通过https来传递此条cookie。 Cookie的创建1234567891011121314151617// 两种方法// 1. 构造时将数据传入Cookie cookie = new Cookie("key", "value");// 2. 构造时无参，然后通过set方法设置数据Cookie cookie = new Cookie();cookie.setName("key");cookie.setValue("value");// 除了核心的数据之外，我们还可以设置一些其他属性// 1. 设置过期时间cookie.setMaxAge(60); //单位：秒(60秒后,Cookie会自动删除)// 2. 设置Domaincookie.setDomain("www.baidu.com"); // 代表只有访问www.baidu.com这个域名下的请求，才能获取到此Cookiecookie.setDomain(".baidu.com"); // 代表所有www.baidu.com下的二级域名包括www.baidu.com这个一级域名都可以共享此Cookie（注意这种情况下domain必须以"."开头）// 3. 设置Path cookie.setPath("/StudentServlet"); // 一旦设置了Path，那么要获取Cookie，当前的请求地址必须满足Path的规则，否则获取不到此Cookie http://xxx:port/student/StudentServlet/getstu/3 Cookie的添加12// 使用响应对象写入浏览器reponse.addCookie(cookie); //本质上会在响应中添加一个Set-Cookie响应头。 Cookie删除1234// Cookie没有delete方法// 我们可以通过设置过期时间为0实现删除cookie.setMaxAge(0);response.addCookie(cookie); Cookie的修改123456// Cookie的修改其实就是覆盖添加// 具体来说分三步// 1. 先获取已有Cookie，// 2. 然后修改其中的数据，// 3. 最后调用response.addCookie()重新添加到浏览器，浏览器看到Key相同的Cookie会自动更新 获取Cookie中的数据123456789// 1. 先通过请求对象获取请求中携带的所有Cookie数组Cookie[] cookies = request.getCookies();// 2. 迭代Cookie数组，寻找要操作的Cookiefor(Cookie cookie : cookies) &#123; // 根据cookie.getName()判断是否是自己要获取数据的cookie // 3. 找到后，调用cookie.getValue()获取数据&#125; SessionSession是什么？Session和Cookie类似，都是用来存储用户信息的。不同于Cookie的是Session是存储在服务器端。他们两者通过JSESSIONID关联起来。 为什么要用Session？虽然Cookie已经可以标识出哪个请求是属于哪个用户的。但是不足的是Cookie本身是存储于客户端硬盘上，安全性不高，不适合存储敏感数据，还有Cookie本身能存储的数据很有限（数据大小本身限制、数据类型限制、字符集限制）。而存储在服务端的Session完全没有这些问题。 什么情况下要使用Session?Session可以用来存储用户的所有信息，理论上所有能在Cookie中存储的数据都可以放到Session中。考虑到Session是基于内存的，如果存储太多不太重要的数据会大大增加服务器端内存压力，一般Session会配合Cookie一起使用。 怎么使用Session?创建Session12// Session是由容器自动创建的，我们可以在代码中直接获取SesssionHttpSession session = request.getSession(); 往Session中存储数据1session.setAttribute(); 获取Session中的数据1session.getAttribute(); 删除Session中的数据1session.removeAttribute(); 修改Session中的数据12345678910// 修改Session中的数据和修改Cookie中的数据类似，都是覆盖添加// 1. 获取要修改的数据Object data = session.getAttribute("key");// 2. 修改数据对应的属性data.setXXX();// 3. 将修改后的数据重新存入Sessionsession.setAttribute("key", data); 强制让Session失效1session.invalidate(); //调用后session对象会失效，同时客户端Cookie中的JSESSIONID也会发生变化]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb分页实现总结]]></title>
    <url>%2Fbv%2F38f6%2F</url>
    <content type="text"><![CDATA[基于MySQL的查询分页物理分页物理分页是直接使用SQL语句通过数据库的特性查询数据库，实现分页，每次从数据库中获取的数据都仅仅是一页的数据。 物理分页的好处就是效率高。 不好的地方就是不同数据库有不同的搞法，因为要依赖查询语句来查询数据库，所以不同的数据库，使用的分页语句也都不相同。 MySQL中的分页：使用limit关键字 12select * from student limit 0, 10-- 表示的是从第0条开始取，取10条数据 逻辑分页逻辑分页就是一次性把数据查询出来，之所以叫逻辑分页就是因为每次从数据库查询数据时没有做分页，而是将取得的所有数据储存到内存缓存中，每次翻页是在内存中对数据做裁剪，取得数据。 逻辑分页的好处就是翻页的速度快，对于数量量比较小来说很适合，数据量大，最好采用物理分页，防止内存溢出。且逻辑分页并不依赖于数据库来实现，所以所有的数据库逻辑分页实现方案都一样。 逻辑分页方法： 根据条件sql查询数据库 得到ResultSet的结果集,由于ResultSet带有游标，因此可以使用其next()方法来指向下一条记录 利用next()方法，得到分页所需的结果集 通用的分页参数参数概览 当前页（前端页面传参） 每页条数（前端页面传参） 总条数（从数据库中查询得到） 总页数（由总页数和每页条数计算得知） 每页要展示的数据 计算公式假设数据库使用的是mysql， 第一页从1开始 总页数算法： 总条数 / 每页条数， 能整除就用商； 不能整除商+1 取当前页数据 开始位置：（当前页 - 1）* 每页条数 结束位置（使用与逻辑分页）：当前页 * 每页条数 取多少条（适用于mysql物理分页）：每页条数]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse导入web项目出现红叉解决办法]]></title>
    <url>%2Fbv%2F366f%2F</url>
    <content type="text"><![CDATA[eclipse导入别人的Java web项目时会出现这种情况：仅项目名出现红叉而其他地方没有红叉的问题。 这可能是以下几种情况导致的，其解决方法如下： 导入项目之前，请确认工作空间编码已设置为utf-8：window-&gt;Preferences-&gt;General-&gt;Wrokspace-&gt;Text file encoding-&gt;Other 选择UTF-8。 导入后，由于你的开发环境中JRE以及Tomcat Library名称可能和源代码中的不一致，可能会出现Build Path的错误，解决方法如下：右键project-&gt;Build Path-&gt;Configure Build Path-&gt;选择Libraries tab页-&gt;删除带小红叉的Library-&gt;点击Add Library-&gt;选择JRE System Library(删了Tomcat Library的话就选择Server Runtime)-&gt;选择一个JRE后-&gt;Finish。 如果web项目能够正常部署且运行无误，进入项目包下的.settings目录，找到org.eclipse.wst.common.project.facet.core.xml文件，用记事本打开后才发现这句话有问题：《runtime name=”Apache Tomcat v6.0”/》。我eclipse中设置的tomcat是9.0版本的，而它的运行环境是8.5版本的tomcat，肯定会出现问题。于是把这句话删掉，刷新工程，红叉消失。]]></content>
      <categories>
        <category>错误解决</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建过程]]></title>
    <url>%2Fbv%2F8045%2F</url>
    <content type="text"><![CDATA[环境准备1.Git下载安装2.Node.JS下载安装安装完成后，要确认是否已经安装成功，在cmd中使用下列命令来验证，有返回的信息就表示安装成功了 git –version node -v npm -v 安装Hexo 在git bash中输入 npm install -g hexo-cli 因为npm默认是从国外的源获取和下载包信息，所以这个命令有时候执行很慢，甚至可能因为被墙导致无法正常安装hexo，安装失败的话建议启用科学上网或百度搜索npm加速方法解决 安装成功后的信息显示如下： 初始化Hexo安装hexo完成后，在电脑中任意位置创建一个文件夹，名字可以随意取，这个文件夹就是存放hexo站点和以后写博客的地方，进入刚刚创建的文件夹，在空白位置右键选择Git Bash Here， 执行初始化hexo的命令 hexo init 初始化完成过程如下： 安装依赖包 npm install 这个命令是用来安装一些Node.js 模块。命令执行的结果如下： git部署安装 npm install hexo-deployer-git –save 完成这一步，hexo的安装就已经完成了。进入站点文件夹查看内容如下： 注意： hexo相关命令均在站点目录下执行，用Git Bash运行 站点配置文件为站点目录下的 _config.yml文件，可以配置大部分的参数 package.json 存放着应用程序的信息，默认已安装EJS, Stylus 和 Markdown renderer等软件 scaffold 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改 source 资源文件夹。是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 themes 主题文件夹，hexo会根据主题来生成静态页面，主题配置文件为主题文件夹下的_config.yml文件 本地预览Hexo博客第一次使用hexo，可以先在本地创建服务器使用 hexo generate # 生成静态页面 //可以直接用hexo g 命令 hexo s # 开启本地服务器 执行情况如下： 接下来到浏览器输入 localhost:4000 就可以看到页面内容了： 至此，Hexo博客已经成功搭建在本地了 部署Hexo博客github准备 首先要有一个github帐号，注册并登录github 然后新建一个仓库， 仓库名为：&lt;Github账号名称&gt;.github.io 将本地Hexo博客推送到新建的github仓库内本教程使用http协议部署hexo博客 修改配置文件blog/_config.yml，修改deploy项的内容（在文件末尾）。 1234deploy: type: git repo: https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：每个标签冒号后面都要有一个空格 输入以下命令将hexo博客部署到github中，返回INFO Deploy done: git即成功推送 hexo clean # 清空静态页面 hexo generate # 生成静态页面 hexo deploy # 上传到仓库 等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io，自此，Hexo博客已经搭建到了github上 在Hexo博客中发布文章新建一篇文章 在hexo博客目录下，进入Git Bash命令窗口，输入以下命令： hexo new “Article” 进入博客目录下的/source/_posts/ 文件夹，可以看到已经生成了名为Article.md的博客文件 如图所示： 打开Article.md文件，进行编辑即可 给文章添加分类和标签在打开的Article.md中，可以看到开头已经自动生成了一段配置列表，在其中设置tags和categories属性： 123456title: Articledate: 2019-09-07 20:46:51tags:- 博客- hexocategories: 测试 添加阅读全文按钮 方法一： 在文章任意你想添加的位置添加如下标签即可 1&lt;!-- more--&gt; 例如jQuery总结.md里的内容是： ---title: Articledate: 2019-09-07 20:46:51tags:- 博客- hexocategories: web前端---## 如何引入jQuery**jQuery本质上就是一段普通的JavaScript代码， 通常使用引入外部JS的方式来使用jQuery**```&lt;script type=&quot;text/javascript&quot; src=“js/jquery.js”&gt;&lt;/script&gt;```&lt;!--more--&gt;以下是正文内容，在首页预览内不显示 在网页上显示的效果是： 方法二： 打开主题配置文件，找到auto_excerpt进行如下修改 123auto_excerpt: enable: true length: 150 length为摘要截取的字符长度 注：这两张方向显示的方法显示的样式不一样，可以都尝试一下选择喜欢的方式进行添加 在文章中插入图片 方法一： 在hexo目录下，安装插件 npm install hexo-asset-image –save 在hexo\source目录下新建一个img文件夹，把图片放置在里面 在xxx.md文件中引用图片 1![header]( img/header.jpg) 方法二： 在全局配置文件hexo/_config.yml中将post_asset_folder设置为true 创建文章（在创建的时候，会在hexo/source/_post目录下，生成一个XXX.md文件和一个XXX的文件夹） 把XXX这个博文需要展示的图片放在XXX文件夹目录下 在XXX.md文件中引入图片的方式 1&#123;% asset_img example.jpg This is an example image %&#125; 方法三： 使用图床工具（本教程中插入的所有图片都是使用sm.ms提供的免费图床服务） 进入sm.ms网站，首页就是上传图片区域，选择要上传的图片点击Upload按钮，底部即会自动生成各种格式的图片链接，复制Markdown专用的链接，粘贴到文章中即可显示图片 启动服务器，在本地进行测试 hexo s 发布文章到github上待发布的文章在本地预览无误后，在Git Bash窗口执行以下命令 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 在浏览器访问网址： https://&lt;Github账号名称&gt;.github.io，即可看到已经发布的文章]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo搭建教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery总结]]></title>
    <url>%2Fbv%2Fa0c7%2F</url>
    <content type="text"><![CDATA[jQuery基础如何引入jQueryjQuery本质上就是一段普通的JavaScript代码， 通常使用引入外部JS的方式来使用jQuery 1&lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt; 基础语法基础语法： $(selector).action() 美元符号定义 jQuery 选择符（selector）”查询”和”查找” HTML 元素 jQuery 的 action() 执行对元素的操作 实例: $(this).hide() - 隐藏当前元素 $(“p”).hide() - 隐藏所有 元素 $(“p.test”).hide() - 隐藏所有 class=”test” 的 元素 $(“#test”).hide() - 隐藏所有 id=”test” 的元素 选择器1$(slector) selector就是选择器表达式，语法基本和CSS选择器一致 示例： $(“#container”) $(“.container”) $(“img”) $(“input[type=’password’]”) $(“#container image”) HTML操作DOM操作jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易 属性操作attr()：用于获取属性值 读取属性 12345$(selector).attr(attrName);//示例var href = $("a").attr("href");var id = $("div").attr("id"); 修改属性 1234$(selector).attr(attrName, "属性值");//示例var href = $("a").attr("href", "http://www.jd.com"); 属性名不仅支持标准属性，还支持自定义属性 内容操作获得内容 text()：设置或返回所选元素的文本内容 html()：设置或返回所选元素的内容（包括 HTML 标记 val()：设置或返回表单字段的值 1234567891011//通过 jQuery text() 和 html() 方法获得内容:$("#btn1").click(function()&#123; alert("Text: " + $("#test").text());&#125;);$("#btn2").click(function()&#123; alert("HTML: " + $("#test").html());&#125;);//通过 jQuery val() 方法获得输入字段的值：$("#btn1").click(function()&#123; alert("值为: " + $("#test").val());&#125;); 样式操作通过 jQuery，可以很容易地对 CSS 元素进行操作 addClass() - 向被选元素添加一个或多个类 1234$("button").click(function()&#123; $("h1,h2,p").addClass("blue"); $("div").addClass("important");&#125;); removeClass() - 从被选元素删除一个或多个类 123$(&quot;button&quot;).click(function()&#123; $(&quot;h1,h2,p&quot;).removeClass(&quot;blue&quot;);&#125;); toggleClass() - 对被选元素进行添加/删除类的切换操作 123$("button").click(function()&#123; $("h1,h2,p").toggleClass("blue");&#125;); css() - 设置或返回样式属性 设置css属性 1$("p").css("background-color","yellow"); 返回css属性 1$("p").css("background-color"); 事件 鼠标事件 键盘事件 表单事件 文档/窗口事件 click keypress submit load dblclick keydown change resize mouseenter keyup focus scroll mouseleave blur unload hover 效果显示隐藏通过 jQuery使用hide()和show() 方法来隐藏和显示 HTML 元素 123456789101112131415//例：&lt;script&gt; $(document).ready(function()&#123; $("#hide").click(function()&#123; $("p").hide(); &#125;); $("#show").click(function()&#123; $("p").show(); &#125;);&#125;);&lt;/script&gt;&lt;p&gt;如果你点击“隐藏” 按钮，我将会消失。&lt;/p&gt;&lt;button id="hide"&gt;隐藏&lt;/button&gt;&lt;button id="show"&gt;显示&lt;/button&gt; 使用 toggle() 方法来切换 hide() 和 show()方法 123$("button").click(function()&#123; $("p").toggle();&#125;); 淡入淡出fadeIn()方法：用于淡入已隐藏的元素 12345$("button").click(function()&#123; $("#div1").fadeIn(); $("#div2").fadeIn("slow"); $("#div3").fadeIn(3000);&#125;); fadeOut()方法：用于淡出可见元素 12345$("button").click(function()&#123; $("#div1").fadeOut(); $("#div2").fadeOut("slow"); $("#div3").fadeOut(3000);&#125;); fadeToogle()方法：可以在 fadeIn() 与 fadeOut() 方法之间进行切换 12345$("button").click(function()&#123; $("#div1").fadeToggle(); $("#div2").fadeToggle("slow"); $("#div3").fadeToggle(3000);&#125;); fadeTo()方法：允许渐变为给定的不透明度（值介于 0 与 1 之间） 12345$("button").click(function()&#123; $("#div1").fadeTo("slow",0.15); $("#div2").fadeTo("slow",0.4); $("#div3").fadeTo("slow",0.7);&#125;); 滑动slideDown()方法：用于向下滑动元素 123$("#flip").click(function()&#123; $("#panel").slideDown();&#125;); slideUp()方法：用于向上滑动元素 123$("#flip").click(function()&#123; $("#panel").slideUp();&#125;); slideToggle()方法：可以在 slideDown() 与 slideUp() 方法之间进行切换 123$("#flip").click(function()&#123; $("#panel").slideToggle();&#125;); 动画使用jQuery animate() 方法可以创建自定义的动画 遍历遍历jQuery对象遍历数组for...in循环语句用于遍历数组或者对象的属性进行循环操作 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作 1234567891011121314151617//语法for (变量 in 对象)&#123; 在此执行代码&#125;//例&lt;script type="text/javascript"&gt; var x var mycars = new Array() mycars[0] = "Saab" mycars[1] = "Volvo" mycars[2] = "BMW" for (x in mycars)&#123; document.write(mycars[x] + "&lt;br /&gt;") &#125;&lt;/script&gt; AjaxjQuery也可以实现异步加载]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Java学习总结</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript总结]]></title>
    <url>%2Fbv%2F6f34%2F</url>
    <content type="text"><![CDATA[JavaScript基础如何引入JavaScript外联文件1&lt;script src="引入的文件位置（本地文件位置或者远程链接）"&gt;&lt;/script&gt; 内联文件123&lt;script type="text/javascript"&gt; js代码编写的位置&lt;/script&gt; Js输出语句用于基本的调试： 123document.write() //向body中写入字符串console.log() //向控制台输出alert() //弹出框 基础语法 语句分号（ ；）结尾，大括号包裹语句块（基本与Java语法类似） 严格区分大小写 没有添加分号时浏览器自动添加，但是消耗资源并且可能添加出错 注释Hbuilder快捷键 Ctrl + / 添加注释** 单行注释：// 多行注释：/* */ JavaScript基本数据类型​ JavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等 Number Js中只有一种数值类型Number Js中的Number可以表示十进制，八进制，十六进制整数，浮点数，科学记数法 Js中的Number基本类型可以精确表示的最大整数是2^53，BigInt可以表述任意大的整数 String 字符串被引号包围。可以使用单引号或双引号 Boolean 布尔值只有两个值 true false，经常用在条件测试中 undefined 表示声明了但未赋值的变量，其值是 undefined ，typeof 也返回 undefined 1234//已经声明的变量未赋值则成为undefined var a; console.log(typeof a);//结果为undefined 任何变量均可通过设置值为 undefined 进行清空。其类型也将是 undefined 空值与 undefined 不是一回事，空的字符串变量既有值也有类型。 1var car = ""; // 值是 ""，类型是 "string" null null表示一个对象不存在，其数据类型为Object 1234//表示一个空对象 var a = null; console.log(typeof a);//结果为object Object Function Function是一个功能完整的对象，作为JS的内置对象之一。JS的普通函数都是Function对象的实例，所以函数本身也是一个对象，就像var一样，只不过这个对象具有可调用特征而已。 function只是一个关键字，用来创建一个普通函数或对象的构造函数。 RegExp RegExp 对象是带有预定义属性和方法的正则表达式对象 正则表达式，在 JavaScript 中，正则表达式常用于两个字符串方法：search() 和 replace() 12search() //使用表达式来搜索匹配，然后返回匹配的位置。replace() //返回模式被替换处修改后的字符串。 正则表达式修饰符 123i //执行对大小写不敏感的匹配g //执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）m //执行多行匹配 Date 日期对象是一个静态的对象，计算机时间会不断变化，但日期对象不会 new Date() 用当前日期和时间创建新的日期对象，参数可以填year, month, ...，用于指定日期和时间创建新的日期对象 1var d = new Date(2018, 11, 24, 10, 33, 30, 0); //变量分别为年、月、日、小时、分钟、秒和毫秒 JSON JSON对象语法 1&#123; "name":"Nya", "age":21, "car":null &#125; JSON 对象被花括号{}包围 JSON对象以键/值对的方式书写 键必须是字符串，值必须是有效的 JSON 数据类型（字符串、数字、对象、数组、布尔或 null） 键和值由冒号分隔 每个键/值对由逗号分隔 访问JSON对象值 使用点（.）访问对象JSON值 12myObj = &#123; "name":"Nya", "age":21, "car":null &#125;;x = myObj.name; 也可以使用户方括号（[]）访问JSON对象值 12myObj = &#123; "name":"Nya", "age":21, "car":null &#125;;x = myObj["name"]; 遍历JSON对象 使用for-in遍历JSON对象 1234myObj = &#123; "name":"Nya", "age":21, "car":null &#125;;for (x in myObj)&#123; document.getElementById("demo").innerHtml += myObj[x];&#125; 对于嵌套的JSON对象，使用点号和括号访问嵌套的JSON对象 12345678910/***实例***/myObj = &#123; "name":"Bill Gates", "age":62, "cars": &#123; "car1":"Porsche", "car2":"BMW", "car3":"Volvo" &#125;&#125; 1234/***访问方法***/x = myObj.cars.car2;//或者：x = myObj.cars["car2"]; 修改值 也是使用点号或括号来修改JSON对象中的任意值 12myObj.cars.car3 = "Mercedes Benz"; //使用点号myObj.cars["car3"] = "Mercedes Benz"; //使用括号 删除对象属性 使用delete删除JSON对象的属性1delete myObj.cars.car1; ​ typeof 操作符的注意点： typeof 是操作符，不是方法。虽然我们经常使用 typeof() 的方式获取对象的数据类型 对 null 取 typeof 是 object（这是因为 null 是 空的对象引用），对函数取 typeof 是 function 123456console.log(typeof null); //返回objectfunction demo()&#123; console.log('demo'); &#125; console.log(typeof demo); // 返回function JavaScript变量JavaScript 变量是存储数据值的容器，作用和Java里的变量类似 其声明形式不需要指定具体类型，统一用var关键字声明 123var x = 7;var y = 8;var z = x + y; Js标识符：所有JavaScript变量必须以唯一的名称标识。这些唯一的名称称为标识符，标识符命名规则与java基本一致 JavaScript 变量可存放多种数据类型： ​ 字符串被包围在双引号或单引号中。数值不用引号。如果把数值放在引号中，会被视作文本字符串。 程序控制语句条件语句用来执行逻辑判断的语句 条件判断语句 123456789var a = 1;if(a = 1)&#123; console.log("A");&#125;else&#123; console.log("B"); if(a != 5)｛ console.log("C"); ｝&#125; 条件分支语句 123456789101112var a = 1; switch(a)&#123; case 1: console.log("1"); break; case 2: console.log("2"); break; default: console.log("其他"); break; &#125; 循环语句使代码能在某种条件下不断执行的语句 for循环 12345678910111213/**语法**/for(初始化变量; 条件表达式; 更新变量)&#123; 语句...&#125; /**例**/function p(i)&#123; document.write(i); document.write("&lt;br&gt;");&#125;for(var i = 0; i &lt; 10; i++)&#123; p(i);&#125; for…in循环： 用于对数组或者对象的属性进行循环操作 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作 1234567891011121314/**语法**/for (变量 in 对象)&#123; 执行代码...&#125;/**例**/var xvar mycars = new Array()mycars[0] = "Saab"mycars[1] = "Volvo"mycars[2] = "BMW"for (x in mycars)&#123; document.write(mycars[x] + "&lt;br /&gt;")&#125; 对象自定义对象 使用new关键字创建对象 12345var person = new Person();person.name = "Nya";person.age = 21;person.sex = "男";//创建了对象的一个新实例，并向其添加了四个属性 new所调用的函数是一个构造函数constructor()，构造函数是专门用来创建对象的函数，使用typeof语句会返回object 通过function设计一个对象 12345678910//创建函数构造器function person(name, age, sex)&#123; this.name = name; this.age = age; this.sex = sex //在JS中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象（运行时）&#125;//创建对象实例var myFather = new person("Ton", 51, "男");var myMother = new person("Sally", 49, "女"); 构造函数内部也可以定义方法 使用JSON创建对象 –-详见数据类型一节-– JS内置对象Window对象 Document对象 Document对象包含当前文档的信息，例如：标题、背景、颜色、表格等 常用方法： 通过write()方法在浏览器中显示内容 getElementById()和getElementByTagName()，这两个方法会忽略文档的结构，可查找整个HTML文档中的任何元素（不论它们在文档中所处的位置，例如通过getElementByTagName()可以把文档中所有的元素找到） cookie方法会返回一个包含所有的cookie的字符串，每条cookie以分号和空格(; )分隔(即key*=*value键值对)： 1allCookies = document.cookie; body方法会返回道歉文档中的&lt;body&gt;元素或者&lt;frameset&gt;元素 Screen对象 window.screen对象在编写时可以不使用 window 这个前缀 一些属性： screen.availWidth - 可用的屏幕宽度 1document.write("可用宽度: " + screen.availWidth); screen.availHeight - 可用的屏幕高度 1document.write("可用高度: " + screen.availHeight); Location对象 location.href 属性 12345//改变当前网页地址（加载新的网页）：location.href = 'http://www.baidu.com';//返回（当前页面的)整个URL：document.write(location.href); History对象 一些方法： history.back() 123456&lt;input type="button" value="Back" onclick="goBack()"&gt;&lt;script&gt; function goBack()&#123; window.history.back() &#125;&lt;/script&gt; 以上代码效果为返回上一页按钮 history.forward() 123456&lt;input type="button" value="Forward" onclick="goForward()"&gt;&lt;script&gt; function goBack()&#123; window.history.forwardk() &#125;&lt;/script&gt; 以上代码效果为跳到下一页按钮 函数JavaScript函数语法1234function functionname( 参数.../*可选*/ )&#123; // 执行代码&#125;//注：JavaScript 对大小写敏感。关键词 function 必须是小写的，并且必须以与函数名称相同的大小写来调用函数 ​ 当调用该函数时，会执行函数内的代码。 ​ 可以在某事件发生时直接调用函数（比如当用户点击按钮时），并且可由 JavaScript 在任何位置进行调用。 获取函数参数 常规方式 通过内置arguments对象获取 自调用函数函数表达式可以 “自调用”，自调用表达式会自动调用。 如果表达式后面紧跟 () ，则会自动调用。 不能自调用声明的函数。 通过添加括号，来说明它是一个函数表达式 1234(function () &#123; var x = "Hello!!"; // 我将调用自己&#125;)();//以上函数实际上是一个匿名自我调用的函数(没有函数名) JavaScript的使用场景添加交互事件​ 对事件做出反应 ​ 可以在事件发生时执行 JavaScript，比如当用户在 HTML 元素上点击时 1&lt;h1 onclick=&quot;this.innerHTML=&apos;Ooops!&apos;&quot;&gt;点击文本!&lt;/h1&gt; 操作DOM元素​ 可以使用JavaScript 来向HTML DOM元素分配事件： 12//例：向button元素分配onclick事件：document.getElementById("myBtn").onclick=function()&#123;displayDate()&#125;; 操作样式​ JavaScript操作style样式 1234//语法dom.style.属性名 = 属性值;//例如：document.getElementsByClassName('box')[0].style.background = 'red'; 验证表单 必填（或必选项目） JavaScript可以用来检查用户是否已填写表达中的必填（或必选）项目。假如必填或必选项为空，那么警告框会弹出 1234567891011121314&lt;form name="myForm" action="demo-form.php" onsubmit="return validateForm()" method="post"&gt;姓: &lt;input type="text" name="fname"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt;function validateForm()&#123; var x=document.forms["myForm"]["fname"].value; if (x==null || x=="") &#123; alert("姓必须填写"); return false; &#125;&#125; Email验证 检查输入的数据是否符合电子邮件地址的基本语法，只能做些基本检查： 输入的数据必须包含 @ 符号和点号(.)。同时，@ 不可以是邮件地址的首字符，并且 @ 之后需有至少一个点号 1234567891011121314&lt;form name="myForm" action="demo-form.php" onsubmit="return validateForm();" method="post"&gt; Email: &lt;input type="text" name="email"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;function validateForm()&#123; var x=document.forms["myForm"]["email"].value; var atpos=x.indexOf("@"); var dotpos=x.lastIndexOf("."); if (atpos&lt;1 || dotpos&lt;atpos+2 || dotpos+2&gt;=x.length)&#123; alert("不是一个有效的 e-mail 地址"); return false; &#125;&#125; 异步请求Ajax请求： 同步请求:只有当一次请求完全结束以后才能够发起另一次请求 异步请求:不需要其他请求结束就可以向服务器发起请求 Ajax：Asynchronous javaScript and xml (异步的JavaScript和xml技术)。 当我们向服务器发起请求的时候，服务器不会像浏览器响应整个页面，而是只有局部刷新。它是一个异步请求，浏览器页面只需要进行局部刷新，效率非常的高 正则匹配 详见上文正则部分 定时器js 定时器有以下两个方法： setInterval不停地重复执行，按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭 使用形式：函数setInterval(函数名, 重复执行的时间间隔毫秒数 ); 12345678910111213141516171819&lt;script&gt;function printTime()&#123; var d = new Date(); var h= d.getHours(); var m= d.getMinutes(); var s= d.getSeconds(); document.getElementById("time").innerHTML= h+":"+m+":"+s;&#125;function showTimeIn3Seconds()&#123; setTimeout(printTime,3000); &#125;&lt;/script&gt;&lt;div id="time"&gt;&lt;/div&gt;&lt;button onclick="showTimeIn3Seconds()"&gt;点击后3秒钟后显示当前时间，并且只显示一次&lt;/button&gt;/**通过setInterval**重复执行同一个函数**，重复的时间间隔由第二个参数指定**/ setTimeout在指定的毫秒数后调用函数或计算表达式 使用形式：函数setTimeout(functionname, 距离开始时间毫秒数 ); 123456789101112131415161718//例：每隔1秒钟，打印当前时间&lt;script&gt;function printTime()&#123; var d = new Date(); var h= d.getHours(); var m= d.getMinutes(); var s= d.getSeconds(); document.getElementById("time").innerHTML= h+":"+m+":"+s;&#125;var t = setInterval(printTime,1000);&lt;/script&gt;&lt;div id="time"&gt;&lt;/div&gt;/**document.getElementById 获取id=time的div元素 .innerHTML 修改该元素的内容**/ 事件事件是JavaScript允许HTML与用户交互的行为。 用户任何对网页的操作，都会产生一个事件 onchange HTML元素改变事件123456789//例：离开输入字段时，会触发一个函数，将输入文本转换为大写&lt;script&gt;function myFunction() &#123; var x = document.getElementById("fname"); x.value = x.value.toUpperCase();&#125;&lt;/script&gt;请输入您的名字：&lt;input type="text" id="fname" onchange="myFunction()"&gt; onclick 鼠标点击事件12345678//例：点击按钮弹出“Hello JavaScript”&lt;script&gt;function showHello()&#123; alert("Hello JavaScript");&#125;&lt;/script&gt;&lt;button onclick="showHello()"&gt;点击一下&lt;/button&gt; onbluronblur 事件会在对象失去焦点时发生 12345678910//例：离开输入框后会将文本转化为大写&lt;script type="text/javascript"&gt;function upperCase()&#123; var x=document.getElementById("fname").value document.getElementById("fname").value=x.toUpperCase()&#125;&lt;/script&gt;输入您的姓名：&lt;input type="text" id="fname" onblur="upperCase()" /&gt; onmouseover / onmouseout12345678910111213//例：鼠标移入移出事件&lt;script&gt;function mOver(obj) &#123; obj.innerHTML = "谢谢您"&#125;function mOut(obj) &#123; obj.innerHTML = "请把鼠标移上来"&#125;&lt;/script&gt;&lt;div onmouseover="mOver(this)" onmouseout="mOut(this)" style="background-color:#D94A38;width:120px;height:20px;padding:40px;"&gt; 请把鼠标移上来&lt;/div&gt; onload1234567891011121314//onload事件&lt;script&gt;function checkCookies() &#123; var text = ""; if (navigator.cookieEnabled == true) &#123; text = "Cookie 已启用"; &#125; else &#123; text = "Cookie 未启用"; &#125; document.getElementById("demo").innerHTML = text;&#125;&lt;/script&gt;&lt;p id="demo"&gt;&lt;/p&gt; onkeydown键盘按下事件]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Java学习总结</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
